---
layout: single
title: '3. 코드 구성하기'
categories: [Hexagonal Architecture, 만들면서 배우는 클린 아키텍처]
tags: [Hexagonal Architecture, Clean Architecture]
toc: true
toc_sticky: true
---

# 1. 계층으로 구성하기

- 웹, 도메인, 영속성 계층 각각에 대해 전용 패키지를 구성
    
    ```
    buckpal
    ├── domain
    |   ├── Account
    |   ├── Activity
    |   ├── AccountRepository
    |   └── AccountService
    ├── persistence
    |   └── AccountRepositoryImpl
    └── web
        └── AccountController
    ```
    
    - 하지만 이 패키지 구조는 최적의 구조가 아님

## 1. 문제 (1): 경계가 없음

- 애플리케이션의 기능 조각이나 특성을 구분 짓는 패키지 경계가 없음
- 관련 없는 기능끼리 예상하지 못한 부수효과를 일으킬 수도

## 2. 문제 (2): 책임이 드러나지 않음

- 애플리케이션이 어떤 유스케이스를 제공하는지 알 수 없음
- 특정 기능을 찾기 위해서는 어떤 서비스가 이를 구현했는지, 해당 서비스 내 어떤 메소드가 해당 책임을 수행하는지 찾아야

## 3. 문제 (3): 아키텍처 파악이 불가

- 패키지 구조를 통해 목표로 하는 아키텍처를 파악할 수가 없음
- 인커밍 포트와 아웃고잉 포트가 코드 속에 숨겨져 있음

# 2. 기능으로 구성하기

- 계층으로 구성하는 방법의 문제점을 해결하기 위해 예제 코드를 기능만으로 구성한 것
    
    ```
    buckpal
    ├── account
    |   ├── Account
    |   ├── AccountController
    |   ├── AccountRepository
    |   ├── AccountRepositoryImpl
    |   └── SendMoneyService
    ...
    ```
    
    - package-private 접근 수준으로 패키지 간의 경계를 강화하면, 각 기능 사이 불필요한 의존성 방지 가능
    - 소리치는 아키텍처: `AccountService`의 책임을 좁히기 위해, `SendMoneyService`로 클래스 명을 변경

### 문제: 아키텍처 가시성

- 하지만 기능에 의한 패키징 방식은 계층에 의한 패키징 방식보다 아키텍처의 가시성을 훨씬 더 떨어트림
    - 어댑터를 나타내는 패키지명이 없고, 인커밍/아웃고잉 포트도 확인이 불가
    - package-private 접근 수준을 이용해 도메인 코드가 실수로 영속성 코드에 의존하는 것을 막을 수 없음

# 3. 아키텍처적으로 표현력 있는 패키지 구조

## 1. `buckpal` 패키지

- 육각형 아키텍처에서 구조적인 핵심 요소인 엔티티, 유스케이스, 인커밍/아웃고잉 포트, 인커밍 아웃고잉 어댑터를 표현하는 패키지 구조는 다음과 같음
    
    ```
    buckpal
    └── account
        ├── adapter
        |   ├── in
        |   |   └── web
        |   |       └── AccountController
        |   ├── out
        |   |   └── persistence
        |   |       ├── AccountPersistenceAdapter
        |   |       └── SpringDataAccountRepository
        ├── domain
        |   ├── Account
        |   └── Activity
        └── application
            └── SendMoneyService
            └── port
                ├── in
                |   └── SendMoneyUseCase
                └── out
                    ├── LoadAccountPort
                    └── UpdateAccountStatePort
    ```
    
    - `account`: 최상위에서 Account 관련 유스케이스를 구현한 모듈임을 나타냄
    - `domain`: 도메인 모델이 위치
    - `application`: 도메인 모델을 둘러싼 서비스 계층을 포함
        - `SendMoneyService`는 인커밍 포트 인터페이스인 `SendMoneyUseCase`를 구현
        - `SendMoneyUseCase`는 아웃고잉 포트 인터페이스 `LoadAccountPort`, `UpdateAccountStatePort`를 사용
    
    - `adapter`: 애플리케이션 계층의 인커밍 포트를 호출하는 인커밍 어댑터, 애플리케이션 계층의 아웃고잉 포트에 대한 구현을 제공하는 아웃고잉 어댑터를 포함

- 이 패키지 구조는 아키텍처-코드 갭을 효과적으로 다룰 수 있으며, 아키텍처에 대한 적극적인 사고를 촉진

## 2. 접근 수준

- 패키지에 들어 있는 모든 클래스들은 `application` 패키지 내의 포트 인터페이스를 통해야 외부로 호출이 됨
    - 따라서 package-private 접근 수준으로 둬도 됨
    - `application` 계층에서 어댑터 클래스로 향하는 우발적 의존성은 있을 수 없음

- 하지만 `application`, `domain` 패키지 내, 어댑터에서 접근해야 하는 포트나 도메인 클래스는 `public`이어어야
- 서비스는 인커밍 포트 인터페이스 뒤에 숨겨질 수 있어, `public`일 필요가 없음

## 3. 장점

- 어댑터 코드를 자체 패키지로 이동시키면, 어댑터를 다른 구현체로 쉽게 교체할 수 있음
- 패키지 구조를 DDD 개념에 직접적으로 대응시킬 수 있음
    - 상위 레벨 패키지(`account`)는 다른 바운디드 컨텍스트와 통신할 전용 진입점과 출구를 포함하는 바운디드 컨텍스트
    - `domain` 패키지 내에서는 DDD가 제공하는 모든 도구를 이용해, 원하는 어떤 도메인이든 만들 수 있음

## 4. 한계

- 패키지 구조를 소프트웨어 프로젝트 내내 유지하기 위해 지켜야 할 규칙이 존재
- 패키지 구조가 적합하지 않아, 어쩔 수 없이 아키텍처를 반영하지 않는 패키지를 만들어야 할 수도
- 완벽한 방법은 없지만, 표현력 있는 패키지는 적어도 코드와 아키텍처 간의 갭은 줄여줌

# 4. 의존성 주입의 역할

## 1. 어댑터 의존성 없애기

- 클린 아키텍처의 가장 본질적인 요건은 애플리케이션 계층이 인커밍/아웃고잉 어댑터에 의존성을 갖지 않는 것

![82fnx455.png](/assets/images/hexagonal architecture/만들면서 배우는 클린 아키텍처/03-코드-구성하기/82fnx455.png)

- **인커밍 어댑터**: 제어 흐름의 방향이 어댑터-도메인 간의 의존성 방향과 같아, 인터페이스 없이도 쉽게 가능
- **아웃고잉 어댑터**: 의존성 역전 원칙을 이용해 의존성을 제어 흐름의 반대 방향으로 돌림
    - 애플리케이션 계층에 인터페이스를 만들고, 어댑터에 해당 인터페이스를 구현한 클래스를 두면 됨

## 2. 문제: 구현체 제공의 주체는?

- 그런데 포트 인터페이스를 구현한 실제 객체를 누가 애플리케이션 계층에 제공해야 하나?
- 포트를 애플리케이션 계층 안에서 수동으로 초기화하면, 어댑터에 대한 의존성이 추가됨

## 3. 해결책: 중립적인 컴포넌트

- 모든 계층에 의존성을 가진 중립적인 컴포넌트를 도입해, 이 문제를 해결할 수 있음
- 이 컴포넌트는 아키텍처를 구성하는 대부분의 클래스를 초기화하는 역할을 수행

# 5. 유지보수 가능한 소프트웨어를 만드는 데 어떤 도움이 될까?

- 육각형 아키텍처 패키지 구조는 실제 코드 구조를 목표로 하는 아키텍처에 가깝게 만들어 줌
- 패키지 구조를 탐색해 코드에서 아키텍처의 특정 요소를 찾을 수 있어, 의사소통, 개발, 유지보수가 수월해짐

---

