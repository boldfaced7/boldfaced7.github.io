---
layout: single
title: '2. 의존성 역전하기'
categories:
  - Hexagonal Architecture
  - 만들면서 배우는 클린 아키텍처
tags:
  - Hexagonal Architecture
  - Clean Architecture
toc: true
toc_sticky: true
---

# 1. 단일 책임 원칙(Single Responsibility Principle)

## 단일 책임 원칙의 일반적인 해석

> 하나의 컴포넌트는 오직 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.

- 이는 좋은 조언이지만, 해당 원칙의 실제 의도는 아님

## 단일 책임 원칙의 실제 정의

> 컴포넌트를 변경할 이유는 오직 하나뿐이어야 한다.

- 컴포넌트를 변경할 이유가 오로지 하나라면, 컴포넌트는 딱 한 가지 일만 하게 됨

## 문제: 변경할 이유가 전파됨

- 컴포넌트를 변경할 이유가 하나라면, 다른 어떤 이유로 소프트웨어를 변경하더라도 해당 컴포넌트를 신경 쓸 필요는 없음
- 하지만 안타깝게도 '변경할 이유'는 컴포넌트 간의 의존성을 통해 너무도 쉽게 전파됨
    
    ![v2fn5qt5.png](/assets/images/hexagonal architecture/만들면서 배우는 클린 아키텍처/02-의존성-역전하기/v2fn5qt5.png)
    
    (실선: 직접 의존, 점선: 전의 의존)
    컴포넌트 A는 다른 여러 컴포넌트에 의존하나, 컴포넌트 E는 의존하는 것이 전혀 없음
    
    - E를 변경할 유일한 이유는 새로운 요구사항에 의해 E의 기능을 바꿔야 할 때뿐
    - 반면 A는 모든 컴포넌트에 의존하고 있어, 어떤 컴포넌트가 바뀌든 같이 바뀌어야

- 많은 코드가 단일 책임 원칙을 위반해,  변경하기 점점 더 어려워지고, 변경 비용도 증가

# 2. 부수효과에 관한 이야기

- 핵심 컴포넌트를 변경할 때마다 다른 무언가가 망가진다면, 새로운 기능을 손쉽게 도입하기가 어려워짐
    - 잘못 구조화된 소프트웨어가 변경에 대한 부수효과를 야기한 것

# 3. 의존성 역전 원칙(Dependency Inversion Principle)

## 정의

> 코드상의 어떤 의존성이든, 그 방향을 바꿀(역전시킬) 수 있다.

- 물론 의존성의 양쪽 코드를 모두 제어할 수 있을 때에만 역전 가능

## 문제: 부수효과 발생

- 단일 책임 원칙을 고수준에서 적용해보면, 상위 계층이 하위 계층에 비해 변경할 이유가 더 많다는 것을 알게 됨
- 따라서 영속성 계층을 변경할 때마다 애플리케이션의 핵심인 도메인 계층도 잠재적으로 변경하게 됨
    
    ![61islqzn.png](/assets/images/hexagonal architecture/만들면서 배우는 클린 아키텍처/02-의존성-역전하기/61islqzn.png)
    

## 해결책: DIP 적용

- 엔티티를 도메인 계층으로 올림
    - 엔티티는 도메인 객체를, 도메인 코드는 해당 엔티티들의 상태 변경을 중심으로 하기 때문

- 영속성 계층의 리포지토리가 도메인 계층의 엔티티에 의존해 순환 의존이 발생하는 부분에 DIP를 적용
    - 도메인 계층에 리포지토리 인터페이스를 만들고, 구현체는 영속성 계층에 작성
    
    ![도메인 계층에 인터페이스를 도입해, 영속성 계층이 도메인 계층에 의존하게 됨](/assets/images/hexagonal architecture/만들면서 배우는 클린 아키텍처/02-의존성-역전하기/jxy75foy.png)
    
    - 도메인 계층에 인터페이스를 도입해, 영속성 계층이 도메인 계층에 의존하게 됨
    

# 4. 클린 아키텍처

## 구조

- 아키텍처의 코어에는 주변 유스케이스에 접근하는 도메인 엔티티가 위치
- 유스케이스(서비스)는 단일 책임을 갖기 위해 조금 더 세분화 됨
- 코어 주변에 비즈니스 규칙을 지원하는 애플리케이션의 다른 모든 컴포넌트들이 위치

![gldue5a1.png](/assets/images/hexagonal architecture/만들면서 배우는 클린 아키텍처/02-의존성-역전하기/gldue5a1.png)

## 특징

- 도메인 코드에서는 어떤 영속성 프레임워크가 사용되는지 알 수 없음
    - 프레임워크 특화 코드를 가질 수 없어, 비즈니스 규칙에만 집중 가능

- 그 결과 도메인 코드를 자유롭게 모델링할 수 있어, 가장 순수한 형태의 DDD 적용 가능

## 효과

- 비즈니스 규칙의 테스트를 용이하게 함
- 비즈니스 규칙은 프레임워크, DB, 그 밖의 외부 애플리케이션/인터페이스로부터 독립적일 수 있음
    - 이는 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야 함을 의미
    - 대신 의존성 역전 원칙의 도움으로, 모든 의존성이 도메인 코드를 향하게 됨

## 주의사항

- 그렇지만 도메인 계층이 외부 계층과 철저하게 분리되어야 해, 애플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수해야
    - JPA는 DB 구조 및 객체 필드와 DB 칼럼의 매핑을 서술한 메타데이터를 담는 엔티티 클래스가 필요
    - 도메인 계층은 영속성 계층을 모르므로 두 계층에서 각각 엔티티를 사용해야 하며, 두 계층이 데이터를 주고 받을 때 두 엔티티를 변환해야

# 5. 육각형 아키텍처(헥사고날 아키텍처)

## 구조

- 육각형 아키텍처는 클린 아키텍처에서 좀 더 일반적으로 설명한 것과 동일한 원칙을 적용
    
    ![dssjcp8n.png](/assets/images/hexagonal architecture/만들면서 배우는 클린 아키텍처/02-의존성-역전하기/dssjcp8n.png)
    

## 육각형 내부

- 도메인 엔티티와 이와 상호작용하는 유스케이스가 존재
- 육각형에서 외부로 향하는 의존성이 없어, 클린 아키텍처의 의존성 규칙이 그대로 적용됨

## 육각형 외부

- 애플리케이션과 상호작용하는 다양한 어댑터가 존재

### 애플리케이션을 주도하는 어댑터

- 애플리케이션 코어를 호출하기 때문에, 애플리케이션을 주도하는 어댑터

### 애플리케이션이 주도하는 어댑터

- 에플리케이션 코어에 의해 호출되기 때문에, 애플리케이션에 의해 주도되는 어댑터

## 내외부 통신

- 애플리케이션 코어와 어댑터 간의 통신이 가능하려면, 애플리케이션 코어가 포트를 제공해야

### Input Port

- 주도하는 어댑터에게 포트는 유스케이스 클래스에 의해 구현되는 인터페이스

### Output Port

- 주도되는 어댑터에게 포트는 어댑터에 의해 구현되는 인터페이스

# 6. 유지보수 가능한 소프트웨어를 만드는 데 어떤 도움이 될까?

- 의존성을 역전시켜 도메인 코드가 다른 외부 코드에 의존하지 않게 해, 영속성 등의 문제로부터 도메인 로직의 결합을 제거하고, 코드를 변경할 이유의 수를 줄일 수 있음
    - 변경할 이유가 적을수록 유지보수성은 더 좋아짐

- 또한 도메인 코드는 비즈니스 문제에 딱 맞도록 자유롭게 모델링될 수 있고, 영속성 코드도 영속성 문제에 맞게 자유롭게 모델링이 가능

---
