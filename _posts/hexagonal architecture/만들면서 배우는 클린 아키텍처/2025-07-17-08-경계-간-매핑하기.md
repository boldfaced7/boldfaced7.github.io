---
title: '8. 경계 간 매핑하기'
layout: single
categories: [Hexagonal Architecture, 만들면서 배우는 클린 아키텍처]
tags: [Hexagonal Architecture, Clean Architecture]
toc: true
toc_sticky: true
---

# 1. '매핑하지 않기' 전략

- 포트 인터페이스가 도메인 모델을 입출력 모델로 사용해, 계층간의 매핑이 필요가 없음
    
    ![e7p0onkd.png](/assets/images/hexagonal architecture/만들면서 배우는 클린 아키텍처/08-경계-간-매핑하기/e7p0onkd.png)
    

## 장점

- 모든 계층이 같은 구조/정보를 가지는 간단한 CRUD 유스케이스에서는 SRP(단일 책임 원칙) 준수가 가능하며, 빠른 개발이 가능
    - 하지만 간단한 CRUD 유스케이스가 영원히 간단하게 남지 않을 수도 있음

## 단점

- 유스케이스 구현 도메인 모델 클래스는 웹/영속성 관련 요구사항을 모두 반영하게 되어, SRP(단일 책임 원칙)을 위반

# 2. '양방향' 매핑 전략

- 각 어댑터가 전용 모델을 가지고 있어, 도메인-전용 모델 간의 매핑이 필요

![2bequkbq.png](/assets/images/hexagonal architecture/만들면서 배우는 클린 아키텍처/08-경계-간-매핑하기/2bequkbq.png)

## 장점

- 도메인 모델에는 오염이 없고, 각 계층이 전용 모델을 변경해도 다른 계층에는 영향이 없어 SRP를 준수
- 매핑 책임이 명확해, 개념적으로 '매핑하지 않기' 전략 다음으로 간단
    - 바깥쪽 계층은 매핑에 집중하고, 안쪽 계층은 도메인 로직에 집중하면 됨

## 단점

- 모델 간 매핑을 구현하며 너무 많은 보일러플레이트 코드가 발생
- 도메인 모델이 계층 경계를 넘는 통신에 사용되어, 바깥쪽 계층의 요구에 따른 변경에 취약해짐
- 간단한 CRUD 유스케이스에서는 개발을 불필요하게 더디게 만들 수도

# 3. '완전' 매핑 전략

- 연산마다 별도의 입출력 모델을 사용해, 각 계층이 각 연산 실행에 필요한 모델로 매핑
    - 유스케이스는 전용 필드, 유효성 검증 로직을 가진 커맨드를 가져, 어떤 필드를 비워둘지 추측할 필요가 없음
    
    ![hgdg8xpp.png](/assets/images/hexagonal architecture/만들면서 배우는 클린 아키텍처/08-경계-간-매핑하기/hgdg8xpp.png)
    
    - **웹 계층**: 입력을 애플리케이션 계층의 커맨드 객체로 매핑할 책임을 가짐
    - **애플리케이션 계층**: 커맨드 객체를 유스케이스에 따라 도메인 변경을 위해 필요한 모델로 매핑할 책임을 가짐

## 장/단점

- 많은 코드가 필요하나, 여러 유스케이스의 요구사항을 함께 다뤄야 하는 매핑에 비해 구현/유지보수가 쉬움

## 적용

- 웹-애플리케이션 계층 사이에서 상태 변경 유스케이스의 경계를 명확히 해야 할 때 사용하는 것을 추천
- 애플리케이션-영속성 계층 사이에서는 매핑 오버헤드 때문에 사용하지 않는 것을 추천
    - 매핑 전략을 전역적으로 사용할 필요는 없음

- 연산의 입력 모델에 대해서만 이 전략을 사용하고, 도메인 객체를 그대로 출력 모델로 사용하는 것도 좋음
    - 예, `SendMoneyUseCase`가 업데이트된 잔고를 가진 채로 `Account` 객체를 그대로 반환

# 4. '단방향' 매핑 전략

- 동일한 상태 인터페이스를 구현하는 도메인/어댑터 모델을 사용해, 각 계층은 다른 계층에서 온 객체를 단방향으로 매핑
    
    ![f69spjvn.png](/assets/images/hexagonal architecture/만들면서 배우는 클린 아키텍처/08-경계-간-매핑하기/f69spjvn.png)
    
    - 모든 모델이 구현하는 인터페이스는 getter를 제공해, 도메인 모델의 상태를 캡슐화

- 단방향 매핑은 계층 간의 모델이 비슷할 때 가장 효과적
    - 읽기 전용 연산은 상태 인터페이스가 필요한 정보를 다 제공해, 웹 계층에서 전용 모델로 매핑할 필요가 없음

## 1. 장점

- 도메인 모델 자체는 풍부한 행동을 구현할 수 있고, 애플리케이션 계층 내 서비스에서 이러한 행동에 접근 가능
- 도메인 객체가 인커밍/아웃고잉 포트가 원하는 상태 인터페이스를 구현하고 있어, 매핑 없이 도메인 객체를 바깥 계층으로 전달 가능
    - 바깥 계층에서는 상태 인터페이스를 이용할지, 전용 모델로 매핑할지 결정할 수 있음
    - 행동 변경이 인터페이스에 정의되어 있지 않아, 도메인 객체 상태를 실수로 변경할 일이 없음

- 이 매핑은 '팩토리(특정한 상태로부터 도메인 객체를 재구성할 책임을 가짐)'라는 DDD 개념과 잘 어울림

## 2. 단점

- 매핑이 계층을 넘나들며 퍼져 있어, 다른 전략에 비해 개념적으로 어려움

# 5. 언제 어떤 매핑 전략을 사용할 것인가?

## 1. 그때그때 다르다

- 각 매핑 전략은 저마다 장단점이 있어, 한 전략을 불변의 전역 규칙으로 적용해서는 안 됨
- 팀 내에서 언제 어떤 전략을 사용할지 결정할 수 있도록 가이드라인을 정해 두어야

## 2. 가이드라인 예제

- 변경 유스케이스 작업 시, 웹-애플리케이션 계층 사이에서는 유스케이스 간 결합 제거를 위해 '완전 매핑'을 사용
    - 유스케이스별 유효성 검증 규칙이 명확해지고, 특정 유스케이스에서 필요하지 않은 필드를 다루지 않아도 됨

- 변경 유스케이스 작업 시, 애플리케이션-영속성 계층 사이에서는 매핑 오버헤드를 줄이기 위해 '매핑하지 않기'를 사용
- 하지만 애플리케이션 계층에서 영속성 문제를 다뤄야 하는 경우, 양방향 매핑으로 바꿔 영속성 문제를 분리

- 쿼리 작업 시, 매핑 오버헤드를 줄이기 위해 '매핑하지 않기' 전략이 우선 고려되어야
- 하지만 애플리케이션 계층에서 영속성/웹 문제를 다뤄야 하는 경우, 양방향 매핑으로 바꿔야

---

