---
layout: single
title: "6. 쓰기 최적화: 이벤트 소싱 패턴"
categories:
  - MSA
  - 도메인 주도 설계로 시작하는 마이크로서비스 개발
  - MSA 애플리케이션 패턴
tags:
  - MSA
  - 이벤트소싱
  - 원자성
  - 동시성
toc: true
toc_sticky: true
---

# 1. 문제: 데이터 저장, 메시지 발신 원자성 확보의 어려움

- 데이터 저장과 메시지 발신의 원자성은 비즈니스 불일치를 피하기 위해 확보되어야
- 그런데 메시지 발행과 저장 처리 기능 수행은 번거롭고 까다로우며 빠르지도 않음
    - 객체 상태 변경에 따라 데이터 모델로 처리되고 최종값이 반영되어야
    - 인스턴스가 늘어나면, 동시성 문제로부터 안전하지 못할 수도

# 2. 해결책: 이벤트 소싱

- **이벤트 소싱**: 상태 변경 이벤트 자체를 이벤트 저장소에 저장
    - 이벤트 저장소는 DB의 역할뿐 아니라, 메시지 브로커처럼 작동하게 됨
    
    ![2.48.png](/assets/images/MSA/도메인 주도 설계로 시작하는 마이크로서비스 개발/MSA 애플리케이션 패턴/06-쓰기-최적화-이벤트-소싱-패턴/2.48.png)
    
    - 상태의 출발점부터 기록된 모든 상태 변경 트랜잭션을 계산해 현재 시점의 상태 확보
    - 주기적으로 상태를 계산해 스냅숏으로 저장하면, 스냅숏 이후의 트랜잭션만 처리해 현재 시점 상태 확보가 가능

- 이벤트 저장소에는 이벤트 id, 이벤트 타입, 엔티티 타입, 변경 내용이 JSON 형태로 저장됨
    - JSON이 객체 형태이므로, 상태 객체가 그대로 들어간 것과 같음
    
    ![2.47.png](/assets/images/MSA/도메인 주도 설계로 시작하는 마이크로서비스 개발/MSA 애플리케이션 패턴/06-쓰기-최적화-이벤트-소싱-패턴/2.47.png)
    

# 3. 이벤트 소싱 장점

- **쓰기 속도 빠름**: 메시지 브로커와 데이터 저장소의 분리 없이 하나로 사용할 수 있기 때문
- **트랜잭션성 이력 로그 기록이 필요 없음**: 특정 시점의 상태가 필요하면 재현 가능
- **동시성 문제가 발생하지 않음**
    - 명령/조회 서비스는 이벤트 저장소에 대한 입력/조회(CR)만 처리
    - 저장소에서 변경/삭제가 발생하지 않아, 명령 서비스를 확장해도 동시성 문제가 발생하지 않음