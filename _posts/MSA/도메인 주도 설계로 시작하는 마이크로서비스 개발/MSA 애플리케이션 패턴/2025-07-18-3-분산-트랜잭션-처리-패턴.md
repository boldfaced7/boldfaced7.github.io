---
layout: single
title: "3. 분산 트랜잭션 처리 패턴"
categories:
  - MSA
  - 도메인 주도 설계로 시작하는 마이크로서비스 개발
  - MSA 애플리케이션 패턴
tags:
  - MSA
  - 분산트랜잭션
  - 사가패턴
  - 결과적일관성
toc: true
toc_sticky: true
---

# 1. 해결책?: 트랜잭션 묶기

- **트랜잭션 묶기**: 여러 개의 분산된 서비스를 하나의 일관된 트랜잭션으로 묶음
- **2단계 커밋**: 분산 트랜잭션 내의 모든 노드를 커밋 또는 롤백해, 원자성을 보장

# 2. 트랜잭션 묶기의 한계

- **잠금 문제**: 각 서비스에 잠금이 걸려, 성능 문제 발생
- **2단계 커밋 지원 문제**: NoSQL 저장소는 2단계 커밋 자체를 지원하지 않음
- **영향도 문제**: 특정 서비스의 트랜잭션이 처리되지 않을 경우, 트랜잭션에 묶인 서비스가 즉시 영향을 받음
    
    **→ 독립적이지 않고 비자율적인 트랜잭션 처리가 발생**
    

# 3. 해결책: 트랜잭션 분리(사가 패턴)

## **사가 패턴이란?**

- 분산된 서비스를 하나의 트랜잭션으로 묶지 않고, 각 로컬 트랜잭션과 보상 트랜잭션을 이용해 트랜잭션을 순차적으로 처리
    
    ![2.38.png](/assets/images/MSA/도메인 주도 설계로 시작하는 마이크로서비스 개발/03-분산-트랜잭션-처리-패턴/2.38.png)
    
    - 각 로컬 트랜잭션은 DB 업데이트를 수행
    - 업데이트 수행 이후 사가 내의 다음 로컬 트랜잭션을 트리거하는 이벤트 게시
    - 어떤 서비스에서 트랜잭션 처리에 실패하면, 보상 트랜잭션으로 이전 처리를 되돌림

## **사가 패턴 사례**

- 주문 처리 시 고객의 신용 한도에 따라 최종 주문을 승인

![2.39.png](/assets/images/MSA/도메인 주도 설계로 시작하는 마이크로서비스 개발/03-분산-트랜잭션-처리-패턴/2.39.png)



1. 주문 처리가 시작되면, 주문 서비스는 가주문을 생성하고, '주문 생성' 이벤트를 발행
2. 고객 서비스는 '주문 생성' 이벤트 확인 후, 신용 한도를 조회해 다음 처리를 수행
    1. 신용 한도 충족: '신용 승인' 이벤트 발행
    2. 신용 한도 미충족: '신용 한도 초과' 이벤트 발행
3. 주문 서비스는 고객 서비스의 발행 이벤트를 확인해 다음 처리를 수행
    1. '신용 승인' 이벤트 수신: 주문 승인 처리
    2. '신용 한도 초과' 이벤트 수신: : 주문 처리 취소


# 4. 데이터 일관성에 대한 생각의 전환: 결과적 일관성

## **실시간 일관성**: 데이터 일관성을 실시간으로 충족

- 한 서비스에서 발생한 장애가 다른 서비스의 가용성을 떨어트릴 수 있음
    
    ![2.40.png](/assets/images/MSA/도메인 주도 설계로 시작하는 마이크로서비스 개발/03-분산-트랜잭션-처리-패턴/2.40.png)
    
    
    
    1. 주문이 폭증해 결제 서비스에서 장애가 발생
    2. 결제 서비스의 장애로 인해 순차적 동시 일관성이 깨짐
    3. 그 결과 주문 처리 역시 지연됨
    
    
    **→ 주문, 결제, 이메일 전송을 순차적으로 처리하기보다, 먼저 주문을 많이 받아야** 
    

## **결과적 일관성**: 데이터 일관성을 일정 시점에 충족

- 이벤트 기반 아키텍처, 메시지 브로커, 사가 패턴으로 비즈니스 정합성을 결과적으로 보장해 각 서비스의 가용성을 극대화
    
    ![2.41.png](/assets/images/MSA/도메인 주도 설계로 시작하는 마이크로서비스 개발/MSA 애플리케이션 패턴/03-분산-트랜잭션-처리-패턴/2.41.png)
    
    
    
    1. 주문 서비스는 가주문을 생성하고 '가주문' 이벤트를 발행
        - '가주문' 이벤트는 메시지 브로커에 비동기로 전송됨
        - 주문이 몰릴 경우, 주문 서비스만 확장해 가용성을 높일 수 있음
    2. 결제 서비스는 '가주문' 이벤트 확인 후, 대금 결제 트랜잭션을 수행해 '결제 처리' 이벤트 발행
    3. 이메일 서비스는 '결제 처리' 이벤트 확인 후, 주문 결제 완료 이메일을 발송
    4. 주문 서비스는 '결제 처리' 이벤트 확인 후, 주문을 최종 승인하고 '최종 주문 완료' 이벤트 발행
    5. 이메일 서비스는 '최종 주문 완료' 이벤트 확인 후, 최종 주문 완료 이메일을 발송
    
    
- 각 서비스는 오류 발생 시 '실패' 이벤트를 발행해, 정합성을 맞출 수 있게 함
- 메시지 큐의 이벤트를 모니터링하고 추적해, 전체적인 비즈니스 정합성을 확인