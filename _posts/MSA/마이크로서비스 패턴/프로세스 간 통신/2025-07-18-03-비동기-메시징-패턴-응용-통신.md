---
layout: single
title: "3. 비동기 메시징 패턴 응용 통신"
categories:
  - MSA
  - 마이크로서비스 패턴
  - 프로세스 간 통신
tags:
  - MSA
  - 메시징
  - 비동기
  - 메시지브로커
toc: true
toc_sticky: true
---

# 1. 메시징 개요

- 메시지는 메시지 채널을 통해 교환됨
    
    ---
    - **송신자 비즈니스 로직**: 송신 포트로 메시지 송신자를 호출해 메시지 채널에 메시지 배포
    - **수신자 메시지 핸들러**: 메시지 채널에서 메시지를 읽어와 수신 포트로 수신자의 비즈니스 로직에 전달
    ---
    ![image.png](/assets/images/MSA/마이크로서비스 패턴/프로세스 간 통신/03-비동기-메시징-패턴-응용-통신/image.png)
    

## **메시지**

- 메시지는 헤더와 본문으로 구성됨
    
    ---
    - **헤더**: 본문의 데이터를 설명하는 키/값 형식의 메타 데이터 집합
        - 메시지 아이디, 응답을 수신할 메시지 채널 등의 추가 정보를 포함
    - **본문**: 텍스트, 이진 포맷으로 전송되는 데이터
    ---

- 메시지는 3가지 유형으로 분류됨
    
    ---
    - **문서**: 데이터만 포함된 메시지로, 커맨드에 대한 응답으로 회신되는 메시지
    - **커맨드**: RPC와 유사한 메시지로, 호출할 오퍼레이션과 매개변수가이 명시됨
    - **이벤트**: 유의미한 상태 변화 발생을 송신자에게 알려주는 메시지로
        - 도메인 객체 상태 변경 발생을 알려주는 도메인 이벤트
    ---

## **메시지 채널**

- 메시지가 교환되어 이동하는 메시징 인프라를 추상화한 개념
    
    ---
    - **점대점 방식**: 컨슈머 하나에게만 메시지를 전달하며, 일대일 상호 작용(커맨드 메시지)을 위해 사용
    - **발행/구독 방식**: 컨슈머 모두에게 메시지를 전달하며, 일대다 상호 작용(이벤트 메시지)을 위해 사용
    ---

# 2. 메시징 상호 작용 스타일 구현

## **요청/응답 및 비동기 요청/응답**

![image.png](/assets/images/MSA/마이크로서비스 패턴/프로세스 간 통신/03-비동기-메시징-패턴-응용-통신/image%201.png)

- 클라이언트가 요청을 보내면, 서비스는 응답을 반환
    
    ---
    - **요청/응답**: 클라이언트는 서비스가 즉시 응답할 것이라고 기대
    - **비동기 요청/응답**: 클라이언트는 서비스가 즉시 응답할 것이라고 기대하지 않음
    ---
    - 메시징은 성격 자체가 비동기적이라 비동기/요청 응답만 제공
    - 하지만 응답을 수신할 때까지 클라이언트 블로킹이 가능

- 클라이언트와 서비스는 한 쌍의 메시지를 교환하며 비동기 요청/응답 스타일로 상호작용
    
    ---
    - **클라이언트**: 수행할 작업과 매개변수가 담긴 커맨드 메시지를 점대점 채널에 전달
    - **서비스**: 요청 처리 결과가 담긴 응답 메시지를 클라이언트의 점대점 채널에 전달
    ---

- 서비스는 어디로 응답 메시지를 보내야 할지 알 수 있어야
    - 클라이언트는 커맨드 메시지를 전송할 때 헤더에 응답 채널을 포함해 전송

- 클라이언트는 전달 받은 응답 메시지가 어떤 요청에 대한 응답인지 찾을 수 있어야
    - 서비스는 요청 메시지에 포함된 `MessageId`를 응답 메시지에 `CorrelationId`로 포함해 응답 채널로 전송
    - 클라이언트는 `CorrelationId`로 요청에 대한 응답이 맞는지 확인

## **단방향 알림**

- 비동기 메시징으로 직관적으로 구현할 수 있음
    
    ---
    - **클라이언트**: 메시지, 통상은 커맨드 메시지를 서비스가 소유한 점대점 채널로 전송
    - **서비스**: 채널을 구독해 커맨드 메시지를 처리하지만 응답을 반환하지는 않음
    ---

## **발행/구독**

- 메시징은 발행/구독 방식의 상호 작용을 기본적으로 지원
    
    ---
    - 메시지 프로듀서: 발행/구독 채널에 메시지를 발행
    - 메시지 컨슈머들: 상기 채널에서 메시지를 읽어 사용
    ---

- 발행/구독 방식은 도메인 객체 상태 변경을 알리는 이벤트 발행에 주로 사용
    
    ---
    - **주문 서비스**: 주문 채널에 주문 상태 변경을 나타내는 이벤트를 발행
    - **연관 서비스**: 주문 채널을 구독하고 이벤트 메시지를 읽어 주문 상태 변경을 파악
    ---

## **발행/비동기 응답**

- 발행/구독과 요청/응답의 요소를 조합해 구현된 고수준 상호 작용
    
    ---
    - **클라이언트**: 응답 채널 헤더가 명시된 메시지를 발행/구독 채널에 발행
    - **컨슈머**: `CorrelationId`가 포함된 응답 메시지를 작성해 응답 채널로 전달
    - **클라이언트**: `CorrelationId`로 요청에 맞는 응답을 찾아 사용
    ---

# 3. 메시징 기반 서비스의 API 명세 작성

- 메시징 기반 API 명세에는 메시지 채널명, 메시지 타입/포맷 등이 명시되어야
    
    ![image.png](/assets/images/MSA/마이크로서비스 패턴/프로세스 간 통신/03-비동기-메시징-패턴-응용-통신/image%202.png)
    
    - 메시지 포맷은 JSON, XML, Protobuf 같은 표준을 사용해 기술되어야

- 단 메시징에는 REST나 Open API와 달리 널리 채택된 표준이 없으니, 자유롭게 기술

## 비동기 작업 문서화

- 서비스 작업은 두 가지 상호 작용 스타일 중 하나로 호출 가능
    
    ---
    - 단방향 알림 스타일 API
        - 서비스의 커맨드 메시지 채널
        - 서비스가 받는 커맨드 메시지 타입/포맷
    
    - 요청/비동기 응답 스타일 API
        - 서비스의 커맨드 메시지 채널
        - 서비스가 받는 커맨드 메시지 타입/포맷
        - 서비스가 반환하는 응답 메시지 타입/포맷
    ---

- 서비스는 요청/비동기 응답, 단방향 알림 모두 동일한 요청 채널 사용이 가능

## 발행 이벤트 문서화

- 서비스는 발행/구독 스타일로도 이벤트 발행이 가능
    
    ---
    - 발행/구독 스타일 API
        - 이벤트 메시지 채널
        - 이벤트 메시지 타입/포맷
    ---

# 4. 메시지 브로커

## **브로커리스 메시징**

- 브로커리스 메시징 아키텍처에서는 서비스들이 직접 통신

### 장점

<aside>

- 네트워크 트래픽이 가볍고 지연 시간이 짧음
- 메시지 브로커가 성능 병목점이 될 일이 없음
- 메시지 브로커를 설정/관리할 필요가 없어, 운영 복잡도가 낮음
</aside>

### 단점

<aside>

- 서비스가 서로의 위치를 알고 있어야 해, 서비스 디스커버리 메커니즘을 사용해야
- 메시지 교환 시 송/수신자 모두 실행 중이어야 해 가용성이 떨어짐
- 전달 보장 메커니즘 구현이 어려움
</aside>

## 브로커 기반 메시징 개요

- 메시지 브로커는 메시지가 지나가는 중간 지점
    
    ---
    - **송신자**: 메시지를 메시지 브로커에게 전달
    - **메시지** 브로커: 메시지를 수신자에게 전달
    ---
    - 송신자가 메시지 컨슈머의 위치를 알 필요가 없음
    - 컨슈머가 메시지를 처리할 수 있을 때까지 메시지를 버퍼링하면서 기다릴 수 있음

## **메시지 브로커 선택 시 고려 사항**

<aside>

- 지원하는 프로그래밍 언어: 가능한 다양한 프로그래밍 언어를 지원하는가?
- 지원하는 메시징 표준: AMQP, STOMP와 같은 주된 메시징 표준을 지원하는가?
- 메시지 전달 순서: 메시지 전달 순서가 유지되는가?
- 메시지 전달 보장: 어떤 종류의 전달 보장을 하는가?
- 영속성: 브로커가 고장나도 문제 없도록 메시지를 디스크에 저장하는가?
- 지속성: 연결이 끊겼다 연결되면, 중단된 기간 동안의 메시지를 수신할 수 있는가?
- 확장성: 얼마나 확장성이 좋은가?
- 지연 시간: 종단 간 지연시간은 얼마나 되는지 확인
- 경쟁사 컨슈머: 경쟁사 컨슈머를 지원하는가?
</aside>

- 브로커마다 일장일단이 존재하므로, 애플리케이션의 요구 사항에 따라 결정해야
    - 지연 시간이 짧은 메시지 브로커는 메시지 전달 순서를 유지하지 못하고, 메시지 전달을 보장하지 않으며 메시지를 메모리에만 보관
    - 메시지 전달을 보장하고 디스크에 메시지를 저장하는 메시지 브로커는 지연 시간이 긴 편

## 메시지 브로커로 메시지 채널 구현

- 메시지 채널은 메시지 브로커마다 구현 방식이 다름
    
    
    | 메시지 브로커 | 점대점 채널 | 발행/구독 채널 |
    | --- | --- | --- |
    | JMS | 큐 | 토픽 |
    | 아파치 카프카 | 토픽 | 토픽 |
    | RabbitMQ | 익스체인지 + 큐 | 팬아웃 익스체인지, 컨슈머 개별 큐 |
    | AWS 키네시스 | 스트림 | 스트림 |
    | AWS SQS | 큐 | - |
    - AWS SQS 제외한 모든 브로커는 점대점, 발행/구독 채널 모두 지원
    

## **브로커 기반 메시징의 장점**

<aside>

- 느슨한 결합: 브로커가 메시지를 중계해, 클라이언트는 서비스의 위치를 몰라도 됨
- 메시지 버퍼링: 브로커는 수신자가 메시지를 처리할 수 있을 때까지 메시지를 버퍼링
    - 수신자가 일시적으로 다운되더라도 메시지를 순서대로 전달할 수 있음
- 유연한 통신: 지금까지 설명한 모든 상호 작용 스타일을 지원
</aside>

## **브로커 기반 메시징의 단점**

<aside>

- 성능 병목 가능성: 메시지 브로커가 성능 저하를 일으키는 병목 지점이 될 수도
    - 요즘 브로커는 대부분 확장이 잘 되도록 설계됨

- 단일 장애점 가능성: 메시지 브로커가 다운되면 전체 시스템이 다운될 수도
    - 요즘 브로커는 대부분 고가용성이 보장되도록 설계됨

- 운영 복잡성: 추가로 설치/설정/운영해야 하는 시스템 컴포넌트가 늘어남
</aside>

# 5. 수신자 경합과 메시지 순서 유지

- 메시지를 동시 처리하려면, 다음 사항을 보장해야
    
    ---
    - 서비스 인스턴스를 여러 개 두어야
    - 각 메시지를 정확하게 한 번만 순서대로 처리해야
    ---

- 3개의 서비스 인스턴스가 동일한 메시지 채널을 구독하고, 송신자가 주문 생성됨, 주문 수정됨, 주문 취소됨 메시지를 순서대로 발행했다고 가정
    - 단순하게 보면 메시지 종류별로 정해진 수신자에 동시 전달하면 됨
    - 하지만 메시지 처리 순서가 어긋나면 시스템이 오작동할 수도
        - 주문 생성 메시지가 처리되기 전에 주문 취소 메시지가 먼저 처리될 수도

- 최근 메시지 브로커는 샤딩된 채널을 이용해 문제를 해결
    
    ---
    - 샤딩된 채널은 복수의 샤드로 구성되며, 각 샤드는 별도의 채널처럼 작동
    - 송신자가 헤더에 샤드 키를 지정하면, 브로커는 메시지를 키별로 샤드/파티션에 배정
    - 브로커는 복수의 수신자 인스턴스를 하나로 묶어 논리적으로 동일한 수신자로 취급
        - 각 샤드를 하나의 수신자에 배정
        - 수신자가 시동/종료하면 샤드를 재배정
    ---

- 다음 그림에서 각 주문 이벤트 메시지는 OrderId를 샤드 키로 가짐
    
    ![image.png](/assets/images/MSA/마이크로서비스 패턴/프로세스 간 통신/03-비동기-메시징-패턴-응용-통신/image%203.png)
    
    
    - 따라서 특정 주문 이벤트들은 동일한 샤드에 발행되어 동일한 컨슈머에 의해 처리됨
    - 결국 메시지들은 순서대로 처리됨

# 6. 중복 메시지 처리

## 문제: 같은 메시지가 여러 번 전달됨

- 메시지는 한 번만 전달되는 게 좋겠지만, 이를 보장하기는 매우 어려움
- 따라서 브로커는 적어도 한 번 전달되도록 구현됨
    
    ---
    - **시스템이 정상**: 한 번만 전달
    - **시스템이 비정상**: 같은 메시지를 여러 번 전달할 수 있음
    ---

- 클라이언트가 메시지를 처리하고 DB를 업데이트하였으나 ACK 전달 전에 문제가 발생
    - 메시지 브로커는 수신 확인을 받지 못했기 때문에 재시작한 클라이언트 또는 레플리카에 동일한 메시지를 전달

- 클라이언트가 이벤트를 `주문 생성됨` → `주문 취소됨` 순서로 처리하는데, 문제가 발생해 `주문 생성됨` 이벤트 ACK를 못 받음
    - 나중에 브로커가 `주문 생성됨` 이벤트만 재전송하면, 클라이언트가 *주문 취소를 취소*할 수도 있음
    - 따라서 `주문 생성됨`, `주문 취소됨` 이벤트를 모두 재전송해야

## **해결책 (1): 멱등성한 메시지 핸들러 작성**

- 브로커가 메시지 재전송 시 순서를 유지하고, 메시지 처리 애플리케이션 로직이 멱등성을 가지면, 중복 메시지는 전혀 문제가 되지 않음
    - 이미 취소된 주문을 다시 취소하는 로직은 멱등성을 가짐
    - 클라이언트가 제공하는 아이디를 가지고 주문을 생성하는 로직도 멱등성을 가짐

- 하지만 멱등한 애플리케이션은 실제로 많지 않고, 메시지 브로커가 재전송 시 순서 보장을 못 할 수도

## **해결책 (2): 메시지를 추적해 중복 메시지 제거**

- 메시지 ID를 저장해, 메시지 처리 여부를 추적하며 중복 메시지를 솎아낼 수 있음
    
    ![image.png](/assets/images/MSA/마이크로서비스 패턴/프로세스 간 통신/03-비동기-메시징-패턴-응용-통신/image%204.png)

    ---
    - 컨슈머가 처리한 메시지의 메시지 ID를 DB에 저장
    - 새로운 메시지가 들어왔을 때 저장된 메시지 ID와 비교
        - 신규 메시지는 처리하고, 중복 메시지는 제거
    ---

# 7. 트랜잭셔널 메시징

## 문제: DB 업데이트와 메시지 전송의 원자성 확보

- 서비스는 보통 DB 업데이트 트랜잭션의 일부로 메시지를 발행
- 이때 DB 업데이트와 메시지 전송이 원자적으로 수행되지 않으면, 서비스가 다운되는 경우 데이터가 불일치할 수도

## **해결책: 트랜잭셔널 아웃박스 패턴**

- 메시지를 DB에 저장해, DB 트랜잭션의 일부로 발행하는 패턴
    
    ---
    - 데이터베이스 테이블(`OUTBOX`)을 임시 메시지 큐로 이용
    - 비즈니스 객체 생성/수정/삭제 DB 트랜잭션의 일부로 `OUTBOX`에 메시지를 삽입
        - 로컬 ACID 트랜잭션이므로, 원자성이 보장됨
    - 메시지 중계기는 `OUTBOX` 테이블을 읽어 브로커에 메시지를 발행
    ---
    ![image.png](/assets/images/MSA/마이크로서비스 패턴/프로세스 간 통신/03-비동기-메시징-패턴-응용-통신/image%205.png)
    

## **이벤트 발행: 폴링 퍼블리셔 패턴**

- 메시지 중계기가 테이블을 폴링해 미발행 메시지를 조회
    
    ```sql
    SELECT * FROM OUTBOX ORDERED BY ... ASC
    ```
    

- 메시지 중계기는 미발행 메시지를 목적지 채널로 보내 브로커에 발행
- 이후 테이블에서 발행 메시지를 삭제
    
    ```sql
    BEGIN
    DELETE FROM OUTBOX WHERE ID in (...)
    COMMIT
    ```
    

- 소규모 메시징을 처리하는 경우 쓸 수 있는 단순한 방법
- 하지만 DB 폴링을 자주하면 비용이 발생하고, NoSQL에서 사용하지 못할 수도

## **이벤트 발행: 트랜잭션 로그 테일링 패턴**

- 트랜잭션 로그(커밋 로그)를 추적해, DB에 반영된 변경분을 메시지로 변환해 발행
    
    ![image.png](/assets/images/MSA/마이크로서비스 패턴/프로세스 간 통신/03-비동기-메시징-패턴-응용-통신/image%206.png)
