---
layout: single
title: "4. 비동기 메시징으로 가용성 개선"
categories:
  - MSA
  - 마이크로서비스 패턴
  - 프로세스 간 통신
tags:
  - MSA
  - 비동기메시징
  - 가용성
  - 데이터복제
toc: true
toc_sticky: true
---
# 1. 문제: 동기 통신으로 인한 가용성 저하

- 동기 프로토콜에서 HTTP 클라이언트는 요청이 응답할 때까지 기다려야 해, 가용성이 저하됨

- 주문 서비스가 유효한 주문인지 확인하기 위해 REST API로 소비자/음식점 서비스를 호출하는 상황을 가정
    
    ![image.png](/assets/images/MSA/마이크로서비스 패턴/프로세스 간 통신/04-비동기-메시징으로-가용성-개선/image.png)
    
    
    
    1. **클라이언트**: 주문 서비스에 HTTP `POST /orders` 요청
    2. **주문 서비스**: 소비자 서비스에 HTTP `GET /consumers/id` 요청해 소비자 정보 조회
    3. **주문 서비스**: 음식점 서비스에 HTTP `GET /restaurants/id` 요청해 음식점 정보 조회
    4. **주문 서비스**: 조회한 소비자/음식점 정보로 올바른 주문인지 확인
    5. **주문 서비스**: 주문 생성
    6. **주문 서비스**: 클라이언트에 HTTP 응답
    
    
    - 소비자/음식점 서비스 중 하나라도 중단되면, 주문 생성은 불가능

- 따라서 가용성을 최대화하려면, 동기 통신을 최소화해야

# 2. 해결책: 동기 상호 작용 제거

## 비동기 상호 작용 스타일

- 가능하면 모든 트랜잭션은 비동기 상호 작용 스타일로 처리하는 것이 가장 좋음

- 클라이언트가 비동기 요청/응답 상호 작용으로 주문을 생성했다고 가정
    
    
    
    1. **클라이언트**: 요청 메시지를 주문 서비스에 전송하여 주문 생성
    2. **주문 서비스**: 다른 서비스와 메시지를 비동기 방식으로 교환
    3. **주문 서비스**: 최종적으로 클라이언트에 응답 메시지를 전송
    
    
    ![image.png](/assets/images/MSA/마이크로서비스 패턴/프로세스 간 통신/04-비동기-메시징으로-가용성-개선/image%201.png)
    
    - 클라이언트와 서비스는 메시징 채널로 메시지를 전송해 비동기 통신 수행
    - 상호 작용 과정 중 어느 쪽도 응답을 대기하며 블로킹되지 않음
    - 메시지 소비 시점까지 브로커가 메시지를 버퍼링해, 매우 탄력적

- 하지만 퍼블릭 API는 대개 REST형이라, 서비스에 동기 API를 포함시켜야 하는 경우가 많음

## **데이터 복제**

- 서비스 요청 처리에 필요한 데이터의 레플리카를 유지하는 방법
    - 데이터 소유 서비스가 발행하는 이벤트를 구독해, 최신 데이터 유지

- 클라이언트가 REST API로 주문 서비스를 호출한 상황을 가정
    
    
    
    1. **클라이언트**: 주문 서비스에 HTTP `POST /orders` 요청
    2. **주문 서비스**: 소비자 데이터 레플리카에서 소비자 정보 조회
    3. **주문 서비스**: 음식점 데이터 레플리카에서 음식점 정보 조회
    4. **주문 서비스**: 조회한 소비자/음식점 정보로 올바른 주문인지 확인
    5. **주문 서비스**: 주문 생성
    6. **주문 서비스**: 클라이언트에 HTTP 응답
    
    
    ![image.png](/assets/images/MSA/마이크로서비스 패턴/프로세스 간 통신/04-비동기-메시징으로-가용성-개선/image%202.png)
    
    - 주문 서비스는 소비자/음식점 데이터 레플리카를 가지고 있으므로, 자기 완비형

- 하지만 대용량 데이터의 레플리카를 만드는 것은 대단히 비효율적
- 다른 서비스가 소유한 데이터를 데이터를 수정해야 하는 상황을 해결할 수 없음

## **응답 먼저 반환 후 마무리**

- 클라이언트에 응답하기 전에, 다른 서비스와의 상호 작용을 지연시키는 방법
    
    
    
    1. 로컬에서 가용한 데이터만 가지고 검증
    2. 메시지를 OUTBOX 테이블에 삽입하는 식으로 DB를 업데이트
    3. 클라이언트에 응답을 반환
    
    
    - 서비스는 요청 처리 중에 다른 서비스와 동기적으로 상호 작용 하지 않음
    - 대신 다른 서비스에 메시지를 비동기 전송
    
- 클라이언트가 REST API로 주문 서비스를 호출한 상황을 가정
    
    
    
    1. **주문 서비스**: 주문을 `PENDING` 상태로 생성
    2. **주문 서비스**: 주문 ID가 포함된 응답을 클라이언트에 반환
    
    1. **주문 서비스**: `ValidateConsumerInfo` 메시지를 소비자 서비스에 전송
    2. **주문 서비스**: `ValidateOrderDetails` 메시지를 음식점 서비스에 전송
    
    1. **소비자 서비스**: `ValidateConsumerInfo` 메시지를 받고 주문 가능 소비자인지 확인
    2. **소비자 서비스**: 주문 가능 소비자인 경우, `ConsumerValidated` 메시지 전송
    
    1. **음식점 서비스**: `ValidateOrderDetails` 메시지를 받고 배달 가능 주문인지 확인
    2. **음식점 서비스**: 배달 가능 주문인 경우, `OrderDetailsValidated` 메시지 전송
    
    1. **주문 서비스**: `ConsumerValidated`, `OrderDetailsValidated` 를 받고 주문 상태를 `VALIDATED`로 변경
    
    
    ![image.png](/assets/images/MSA/마이크로서비스 패턴/프로세스 간 통신/04-비동기-메시징으로-가용성-개선/image%203.png)
    
    - 검증 메시지를 받는 순서와 관계 없이 검증 처리가 가능

- 소비자 서비스가 내려가더라도, 주문 서비스는 계속 주문을 생성하고 클라이언트에 응답이 가능
    - 소비자 서비스가 재가동되면, 큐에 쌓인 메시지를 처리해 밀린 주문을 검증할 수 있음

- 클라이언트 입장에서 주문 생성 성공 여부를 알아내려면, 주기적으로 폴링하거나 주문 서비스가 알림 메시지를 보내야