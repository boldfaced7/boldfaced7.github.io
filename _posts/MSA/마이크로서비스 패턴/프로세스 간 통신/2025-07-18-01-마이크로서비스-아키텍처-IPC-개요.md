---
layout: single
title: "1. 마이크로서비스 아키텍처 IPC 개요"
categories:
  - MSA
  - 마이크로서비스 패턴
  - 프로세스 간 통신
tags:
  - MSA
  - IPC
  - API
  - 시맨틱버저닝
toc: true
toc_sticky: true
---
# 1. 상호 작용 스타일

- 서비스/클라이언트 상호 작용 스타일은 두 가지 분류 기준에 따라 나눌 수 있음
    - 상호 작용하는 서비스와 클라이언트의 수
        
        
        
        - **일대일**: 각 클라이언트 요청을 한 서비스가 처리
        - **일대다**: 각 클라이언트 요청을 여러 서비스가 협동해 처리
        
        
    - 응답 방식
        
        
        
        - **동기**: 클라이언트는 서비스가 제 시간에 응답하리라 기대하고, 대기 도중 블로킹
        - **비동기**: 클라이언트는 서비스가 즉시 응답하리라 기대하지 않고, 대기 도중 블로킹하지 않음
        
        

- 각 스타일에 따른 상호 작용 종류는 다음과 같음
    
    
    |  | 일대일 | 일대다 |
    | --- | --- | --- |
    | 동기 | 요청/응답 | - |
    | 비동기 | 비동기 요청/응답
    단방향 알림 | 발행/구독
    발행/비동기 응답 |
    
    
    
    - **요청/응답**: 클라이언트는 응답을 회신할 때까지 대기해, 서비스가 강하게 결합됨
    - **비동기 요청/응답**: 클라이언트는 대기하지 않고 서비스는 비동기적으로 응답
    - **단방향 알림**: 클라이언트는 서비스에 일방적으로 요청하고, 서비스는 응답을 보내지 않음
    - **발행/구독**: 클라이언트는 알림 메시지를 발행하고 관련 서비스들은 이를 구독
    - **발행/비동기 응답**: 클라이언트는 알림 메시지를 게시하고 일정 시간 동안 응답을 대기
    
    

# 2. 마이크로서비스 API 정의

- API는 소프트웨어 개발의 핵심
    - 잘 설계된 API는 유용한 기능을 외부에 제공하되 구현을 드러내지 않음

- 문제는 API 정의/관리가 그리 간단하지 않다는 것
    - 서비스 API는 프로그래밍 언어의 일부가 아니므로, 런타임에 에러가 발생

- 따라서 API는 인터페이스 정의 언어로 명확하게 정의해야
    
    
    
    - 인터페이스 명세 작성
    - 클라이언트 개발자와 명세를 검토하며 고도화
    - 이후 서비스 구현 시작
    
    

- API는 어떤 IPC를 사용하느냐에 따라 구성이 달라짐
    
    
    
    - **메시징**: 메시지 채널, 메시지 유형, 메시지 포맷으로 구성됨
    - **HTTP**: URL, HTTP 동사 요청/응답 포맷으로 구성됨
    
    

# 3. API 발전시키기

## 문제: API는 시간에 따라 계속 변함

- **모놀리식 애플리케이션**: API를 변경하고 클라이언트 코드를 수정하는 것이 상대적으로 간단
- **MSA 기반 애플리케이션**: API를 변경하고 모든 클라이언트를 일괄 업데이트하는 것은 불가능
    - 클라이언트가 다른 팀에서 개발된 서비스이거나 외부에서 개발된 애플리케이션이기 때문
    - 요즘에는 유지/보수를 위한 다운 타임 없이 신/구 버전 서비스를 동시에 운영하기도

## 해결책: 시맨틱 버저닝

- 시맨틱 버저닝은 어떻게 버전 번호를 사용하고 증가시켜야 하는지를 규정하는 일련의 규칙
- 버전 번호는 MAJOR, MINOR, PATCH의 3개로 구성되며 다음 규칙을 따름
    
    
    
    - MAJOR: 기존 API와 호환이 되지 않은 변경
    - MINOR: 기존 API와 호환성을 유지하는 변경
    - PATCH: 기존 API와 호환성을 유지하면서 오류를 수정
    
    

## 하위 호환되는 Minor 변경

- 다음과 같이 API에 무언가를 추가하는 변경은 대부분 하위 호환이 가능
    
    
    
    - 옵션 속성을 요청에 추가
    - 속성을 응답에 추가
    - 새 작업을 추가
    
    

- 이 때, 견고성 원칙을 지원하는 요청/응답 포맷을 사용해 기능을 추가해야
    
    > *"당신이 하는 일은 보수적으로, 다른 사람이 하는 일은 관대하게 바라보라"*
    
    
    - **서비스**: 요청 속성이 누락된 경우 기본 값으로 처리할 수 있어야
    - **클라이언트**: 전달 받은 응답에 추가적인 속성이 있어도 이를 무시할 수 있어야
    
    

## 호환성을 깨는 Major 변경

- 이전 버전과 호환이 되지 않는 Major 변경을 만들어야 하는 경우도 존재
- 모든 클라이언트를 한 번에 업그레이드할 수 없으므로, 일정 기간 동안 신구 버전 API를 모두 지원해야

- HTTP 기반 REST API라면, URL에 Major 버전 번호를 삽입할 수도
    
    
    
    - **버전 1 경로**: `/v1/…`를 포함
    - **버전 2 경로**: `/v2/…`를 포함
    
    

- HTTP의 컨텐트 협상을 이용해, 버전 번호를 MIME 타입에 포함할 수도
    
    ```java
    GET /orders/xyz HTTP/1.1
    Accept: application/vnd.example.resource+json; version=1
    ...
    ```
    

- 신구 버전을 모두 지원하려면, 서비스 API를 구현하는 어댑터에서 신구 버전을 중계하는 로직이 필요

# 4. 메시지 포맷

- 메시지 포맷의 선택은 IPC의 효율성, API의 유용성과 발전성에 영향을 미침
- HTTP의 경우엔 다수의 언어에서 지원하는 메시지 포맷을 선택해야

## 텍스트 메시지 포맷

### 장점



- 사람이 읽을 수 있음
- 메시지 만으로 내용이 충분히 전달됨


- 예) JSON, XML
    - 메시지 소비자가 필요한 속성만 선택하고 나머지는 무시할 수 있는 포맷
    - 따라서 메시지 스키마가 바뀌어도 하위 호환성이 쉽게 보장딤

### 단점



- 메시지가 너무 쉽게 커짐(속성 값 + 속성 명)
- 메시지 파싱에 오버헤드가 발생


## 바이너리 메시지 포맷

- 프로토콜 버퍼, 아브로가 유명

### 공통점



- 메시지 구조 정의에 필요한 규격화된 타입 IDL을 제공
- 컴파일러는 메시지의 직렬화/역직렬화를 위한 코드를 자동으로 생성
- 따라서 자연스럽게 API-First 전략을 따르게 됨
- 클라이언트를 정적 유형 언어로 만든 경우, 컴파일 시점에 API를 잘 사용하는지 점검할 수 있음


### 차이점



- **프로토콜 버퍼**: 태그가 달린 필드 사용
- **아브로**: 스키마를 알아야만 메시지 해석이 가능


- 따라서 API 발전 측면에서는 프로토콜 버퍼가 좀 더 용이