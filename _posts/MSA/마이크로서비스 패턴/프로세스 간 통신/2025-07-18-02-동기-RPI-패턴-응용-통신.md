---
layout: single
title: "2. 동기 RPI 패턴 응용 통신"
categories:
  - MSA
  - 마이크로서비스 패턴
  - 프로세스 간 통신
tags:
  - MSA
  - RPI
  - REST
  - gRPC
  - 회로차단기
toc: true
toc_sticky: true
---
# 1. 동기 RPI 패턴: REST

- **REST**: HTTP를 사용하는 IPC
    
    > *REST는 컴포넌트 상호 작용의 확장성, 인터페이스 일반화, 컴포넌트의 독립적인 배포, 통신 지연을 줄이기 위한 중간 컴포넌트, 보안 강화, 레거시 시스템의 캡슐화에 역점을 둔 아키텍처 제약 사항을 제공한다.*

- **리소스**: 비즈니스 객체(들)을 나타내는 REST의 핵심 개념
- **HTTP 동사**: 리소스를 관리(가공 및 조작) 수단
    
    ---
    - `GET` 요청: XML/JSON로 표현된 리소스의 표현형을 반환
    - `POST` 요청: 리소스를 생성
    - `PUT` 요청: 리소스를 수정
    ---

## REST 성숙도 모델 (REST Maturity Model)

<aside>

Level 0: 서비스별 단일 엔드포인트로 작업 대상, 내용, 매개변수가 담긴 POST 요청을 전달

Level 1: 리소스의 개념은 지원하나, POST만으로 서비스에 요청을 전달

Level 2: 다양한 HTTP 동사를 사용해 서비스에 요청을 전달

Level 3: HATEOAS 원칙에 기반해, 응답에 리소스 조작 요청 링크를 포함해 전달

</aside>

## **REST API 명세서 작성하기**

- API는 인터페이스 정의 언어로 정의되어야 하는데, REST는 IDL이 없었음
- 최근에 IDL의 가치를 인정받으면서 Open API Specification이 REST IDL로 널리 사용됨

## **요청 한 번으로 많은 리소스를 가져오기 어려움**

### 문제: 복수의 연관 객체 정보 조회

- REST는 비즈니스 객체 중심 IPC
- 따라서 REST는 단 건 요청으로 복수의 연관 객체 정보 조회가 어려움

### 해결책: 연관 리소스도 조회

- 클라이언트가 리소스를 가져올 때, 연관 리소스도 함께 조회하도록 하는 것
- `GET /orders/order-id-1345?expand=consumer`는 주문과 소비자 정보를 함께 가져올 수 있음
- 통상적으로는 이 방법으로 충분

### 한계

<aside>

- 다소 복잡한 시나리오를 처리하지는 못함
- 구현에 많은 시간이 소요됨
</aside>

- 효율적인 데이터 조회를 지원하도록 설계된 GraphQL, Netflix Falcor 등의 대안적인 API 기술이 각광 받기 시작

## **작업을 HTTP 동사에 매핑하기 어려움**

### 문제: HTTP 동사가 한정됨

- 비즈니스 객체에 수행할 작업을 HTTP 동사에 어떻게 매핑할지도 고민거리
- 데이터 수정 동사는 PUT 하나이나, 수정 유형은 여러가지(주문 취소, 주문 재처리 등)
- 또한 수정 작업이 PUT을 사용할 때 요구되는 멱등 법칙(idempotent)을 따르지 않을 수도

### 해결책: 하위 리소스

- 리소스의 특정 부분을 업데이트하는 하위 리소스를 정의
    
    ---
    주문 취소 엔드포인트: `POST /orders/{orderId}/cancel`
    
    주문 변경 엔드포인트: `POST /orders/{orderId}/revise`
    
    ---

## **REST 장단점**

### 장점

<aside>

- 쉽고 익숙함
- POSTMAN, curl 등으로 간편하게 테스트 가능
- 요청/응답 스타일 통신을 직접 지원
- HTTP가 방화벽에 친화적인 프로토콜
- 중개 브로커가 필요 없어, 시스템 아키텍처가 단순해짐
</aside>

### 단점

<aside>

- 요청/응답 스타일의 통신만 지원
- 한번의 요청으로 복수의 리소스를 가져오는 것이 매우 어려움
- 복수의 업데이트 오퍼레이션을 HTTP 동사로 매핑하기 어려움
- 서비스 가용성이 떨어짐
    - 매개자 없이 클라이언트/서비스가 직접 통신해, 교환 중 양 쪽 다 실행 중이어야
</aside>

# 2. 동기 RPI 패턴: gRPC

- gRPC는 이진 메시지 기반의 프로토콜로, 자연스럽게 API 우선 접근법을 따르게 됨
    - 프로토콜 버퍼의 IDL을 사용해, 구조화된 데이터의 직렬화를 지원
    - 컴파일러로 클라이언트 사이드 스텁과 서버 사이드 스켈레톤 생성이 가능

- 프로토콜 버퍼 포맷의 이진 메시지를 HTTP/2를 사용하여 메시지를 교환
- 하나 이상의 서비스와 요청/응답 데피니션으로 구성됨
    - 서비스 데피니션은 정적 타입 메소드들의 집합으로, 자바의 인터페이스와 유사

- 스트리밍 RPC도 지원
    - 서버가 클라이언트에 메시지 스트림을 반환할 수도 있음
    - 클라이언트가 서버에 메시지 스트림을 보낼 수도 있음
- 프로토콜 버퍼를 메시지 포맷으로 사용해, 하위 호환성을 유지하며 API 발전이 가능
    - 각 필드마다 번호가 매겨지고 타입 코드가 할당됨
    - 메시지 수신자는 필요한 필드만 추출하고 모르는 필드는 건너 뛸 수 있음

## 예시: 주문 서비스 gRPC API

- `createOrder()`는 `CreateOrderRequest`를 요청 메시지로 받고, `CreateOrderReply`를 응답 메시지로 반환
    
    ```protobuf
    service OrderService {
    	rpc createOrder(CreateOrderRequest) returns (CreateOrderReply) {}
    	rpc cancelOrder(CancelOrderRequest) returns (CancelOrderReply) {}
    	rpc reviseOrder(ReviseOrderRequest) returns (ReviseOrderReply) {}
    	...
    }
    
    message CreateOrderRequest {
    	int64 restaurantId = 1;
    	int64 consumerId = 2;
    	repeated LineItem lineItems = 3;
    	...
    }
    
    message LineItem {
    	string menuItemId = 1;
    	int32 quantity = 2;
    }
    
    message CreateOrderReply {
    	int64 orderId = 1;
    }
    ...
    ```
    

## **gRPC의 장점**

<aside>

- 다양한 업데이트 작업을 제공하는 API 설계하기 쉬움
- 효율적이고 간결한 IPC 메커니즘을 가지고 있어, 대량의 메시지 교환에 효과적
- 양방향 스트리밍으로 인해 RPI와 메시징 방식을 모두 사용 가능
- 서로 다른 언어로 만들어진 클라이언트/서비스 간 연동이 가능
</aside>

## **gRPC의 단점**

<aside>

- 자바스크립트 클라이언트가 하는 일이 REST/JSON API에 비해 더 많음
- 구형 방화벽은 HTTP/2를 지원하지 않을 수도
</aside>

# 3. 부분 실패 처리: 회로 차단기 패턴

- 분산 시스템에서 다른 서비스를 동기 호출하면, 언제나 부분 실패가 발생할 수 있음
    
    ---
    - 유지/보수나 기술적 오류로 서비스가 다운된  경우
    - 과도한 요청으로 인해 응답이 매우 늦어지는 경우
    ---
    ![image.png](/assets/images/MSA/마이크로서비스 패턴/프로세스 간 통신/02-동기-RPI-패턴-응용-통신/image.png)
    

- 클라이언트는 응답 대기 중 블로킹되기 때문에, 서비스 실패는 전이되어 전체 시스템이 중단될수도
- 따라서 부분 실패가 애플리케이션 전체에 전파되지 않도록 설계해야
    
    ---
    - 무응답 서비스를 처리하기 위해 견고한 RPI 프록시 설계
    - 원격 서비스 실패 시 어떻게 조치할 지 결정
    ---

## **무기한 대기 상태 피하기**

- 넷플릭스에서 소개하는 동기 호출 시 스스로를 방어하는 방법은 다음과 같음
    
    ---
    - **네트워크 타임아웃**: 응답 대기 제한 시간을 설정해 리소스의 무한정 대기를 방지
    - **미처리 요청 개수 제한**: 특정 서비스에 요청 가능한 미처리 요청 상한선을 설정하고, 상한선 도달 시 실패 처리
    - **서킷 브레이커 패턴**:성공/실패 요청 개수를 지켜보다, 에러율의 상한선 도달 시 실패 처리
        - 타임 아웃 시간 이후 재시도가 성공하면 서킷 브레이커를 닫음
    ---

- 넷플릭스 히스트릭스는 위 기능을 포함해 다양한 패턴을 구현한 오픈 소스 라이브러리
    - JVM을 사용한다면 RPI 프록시 구현에 히스트릭스 사용 추천

## 원격 서비스 응답 실패 처리

- 히스트릭스와 같은 라이브러리를 사용하는 것은 부분적인 솔루션일뿐
- 동기 호출한 서비스가 응답이 없는 경우, 어떤 처리를 할 것인지 상황별로 대응 방안을 정해야
    - 가장 쉬운 방법은 클라이언트에게 에러를 반환하는 것
    - 기본 값, 캐시 값과 같이 사전에 정의된 값을 응답으로 회신하는 것이 적합하기도
    
    ![image.png](/assets/images/MSA/마이크로서비스 패턴/프로세스 간 통신/02-동기-RPI-패턴-응용-통신/image%201.png)
    

# 4. 서비스 디스커버리

## 문제: 서비스 주소가 바뀜

- 분산 시스템에서 서비스를 호출하려면 해당 서비스의 네트워크 주소를 알아야

- 전통적인 애플리케이션은 서비스의 네트워크 주소가 거의 변하지 않아, 설정 파일에 기록해 놓고 필요할 때 읽어오면 됨
- 하지만 클라우드 기반 마이크로서비스 애플리케이션은 서비스 네트워크 주소가 동적으로 변함
    - 자동 확장, 실패, 업그레이드 등

## 해결책: 서비스 디스커버리

- 결국 클라이언트는 서비스의 주소를 찾기 위하여 서비스 디스커버리 메커니즘을 이용해야
    
    ![image.png](/assets/images/MSA/마이크로서비스 패턴/프로세스 간 통신/02-동기-RPI-패턴-응용-통신/image%202.png)
    

- 서비스 디스커버리는 서비스 인스턴스 시작/종료될 때마다 서비스 레지스트리를 업데이트
- 클라이언트가 서비스를 호출하면 서비스 레지스트리에서 가용 서비스 인스턴스 목록을 조회
- 조회한 서비스 중 하나에 요청을 라우팅

## **애플리케이션 수준 서비스 디스커버리 패턴**

- 서비스와 클라이언트가 서비스 레지스트리와 직접 통신
    
    ---
    1. **서비스 인스턴스**: 자신의 네트워크 주소를 서비스 레지스트리에 등록
    2. **클라이언트**: 서비스 레지스트리에서 서비스 인스턴스 목록 조회
    3. **클라이언트**: 조회된 서비스의 인스턴스 중 하나로 요청을 라우팅
    ---
    ![image.png](/assets/images/MSA/마이크로서비스 패턴/프로세스 간 통신/02-동기-RPI-패턴-응용-통신/image%
    

### 자가 등록

- 서비스 인스턴스가 서비스 레지스트리의 API를 호출해 자신의 네트워크 주소를 등록
- 레지스트리가 서비스 인스턴스 상태를 확인할 수 있도록, 서비스가 헬스 체크 URL을 제공하기도
- 서비스가 등록한 네트워크 위치가 만료되지 않도록, 서비스 레지스트리가 주기적으로 하트비트 API를 호출하기도

### 클라이언트 사이드 디스커버리

- 클라이언트가 서비스를 호출할 때, 서비스 레지스트리에서 서비스 인스턴스 목록을 조회
- 이후 부하 분산 알고리즘(라운드 로빈, 랜덤 등)으로 서비스 인스턴스를 선택

### 오픈 소스 라이브러리

- 넷플릭스는 유레카(고가용성 서비스 레지스트리), 유레카 자바 클라이언트, 리본(유레카 클라이언트릴 지원하는 HTTP 클라이언트) 등을 개발
- 피보탈은 넷플릭스 컴포넌트들을 사용하기 쉽게 만든 스프링 클라우드를 개발
    - 스프링 클라우드 기반 서비스는 유레카에 자동 등록됨
    - 스프링 클라우드 기반 클라이언트는 유레카를 기본 디스커버리로 사용

### 장점

- 애플리케이션이 사용하고자 하는 배포 플랫폼이 하나가 아닌 경우 유용
- 일부 서비스만 쿠버네티스에 배포하고, 나머지는 레거시 환경에서 실행할 수도 있음

### 단점

- 애플리케이션에서 사용하 모든 언어/프레임워크를 지원하는 서비스 디스커버리 라이브러리가 필요
- 서비스 레지스트리를 직접 설정/관리해야

## **플랫폼 내장 서비스 디스커버리 패턴**

- 도커, 쿠버네티스 등의 최신 배포 플랫폼은 서비스 등록/디스커버리/라우팅을 모두 관장
    
    ---
    - **배포 플랫폼**: 각 서비스에 가상의 IP 주소(VIP)인 DNS명을 부여
    - **클라이언트**: 서비스의 DNS명으로 요청을 전송
    - **배포 플랫폼**: 가용 서비스 인스턴스 중 하나에게 요청을 전달
    ---
    ![image.png](/assets/images/MSA/마이크로서비스 패턴/프로세스 간 통신/02-동기-RPI-패턴-응용-통신/image%204.png)
    

### 서드파티 등록 패턴

- 배포 플랫폼의 일부인 등록기라는 서드파티가 서비스를 레지스트리에 등록

### 서버 사이드 디스커버리 패턴

- 클라이언트가 서비스 레지스트리에 질의하지 않고 DNS명을 요청
- 플랫폼 라우터가 서비스 레지스트리를 조회해, 부하가 분산될 수 있도록 요청을 라우팅

### 장점

- 서비스 탐색의 모든 부분이 배포 플랫폼에 의해 관리됨
- 따라서 서비스, 클라이언트는 서비스 탐색에 대한 코드를 작성할 필요가 없음

### 단점

- 해당 플랫폼을 사용해 배포한 서비스의 탐색만 지원
    - 쿠버네티스 기반 디스커버리는 쿠버네티스로 배포한 서비스에만 동작

- 이런 한계가 있지만, 플랫폼이 제공하는 서비스 탐색 기능을 이용하는 것을 추천