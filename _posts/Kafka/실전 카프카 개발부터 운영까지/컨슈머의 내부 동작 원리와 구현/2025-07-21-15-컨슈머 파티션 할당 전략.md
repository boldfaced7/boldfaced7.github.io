---
layout: single
title: "4. 컨슈머 파티션 할당 전략"
categories:
  - Kafka
  - 실전 카프카 개발부터 운영까지
  - 컨슈머의 내부 동작 원리와 구현
tags:
  - Kafka
  - 실전 카프카 개발부터 운영까지
  - 컨슈머의 내부 동작 원리와 구현
toc: true
toc_sticky: true
---
# 1. `RangeAssignor`: 레인지 파티션(기본)

## 1. 할당 방식

- 토픽별로 파티션을 할당
    
    ![20241217_192814.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/컨슈머의 내부 동작 원리와 구현/15-컨슈머 파티션 할당 전략/20241217_192814.png)
    
    - 컨슈머를 순서대로 정렬 후, 각각에 $n(Consumer)/n(Partition)$개만큼 파티션을 할당
    - 나누어 떨어지지 않는 경우, 앞쪽의 컨슈머에게 추가 파티션을 할당

## 2. 특징

- 동일 키를 이용하는 2개 이상의 토픽 소비 시 유용
    
    ---
    - 토픽 1의 파티션 0, 토픽 2의 파티션 0이 모두 키값 abc에 기록된다고 가정
    - 해당 전략 사용 시, 컨슈머 1에 토픽 1의 파티션 0, 토픽 2의 파티션 0이 모두 할당됨
    ---
- 이와 같은 특수한 상황에는 좋지만, 균등한 분배가 되지 않으므로 주의해야

# 2. `RoundRobinAssignor`: 라운드 로빈 파티션

## 1. 할당 방식

- 순서대로 하나씩 파티션과 컨슈머를 할당
    
    ![20241217_192826.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/컨슈머의 내부 동작 원리와 구현/15-컨슈머 파티션 할당 전략/20241217_192826.png)
    

## 2. 특징

- 파티션-컨슈머의 균등 매핑이 가능

# 3. `StickyAssignor`: 스티키 파티션

## 1. 목적

1. 가능한 한 **균형** 잡힌 파티션 할당
2. 재할당 발생 시, **기존** 할당된 파티션 정보를 **보장**
    - 후순위 목적으로, 일부 파티션은 새로운 컨슈머와 연결될 수도

## 2. 할당 방식

### 최초 배치

- 라운드 로빈 전략과 매우 흡사

![20241217_192854.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/컨슈머의 내부 동작 원리와 구현/15-컨슈머 파티션 할당 전략/20241217_192854.png)

### 컨슈머 이탈 후 라운드 로빈

![20241217_192912.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/컨슈머의 내부 동작 원리와 구현/15-컨슈머 파티션 할당 전략/20241217_192912.png)

1. 컨슈머 2가 그룹에서 **이탈**
2. **리밸런싱** 발생
    - 그룹 내 **모든 컨슈머**의 파티션 연결도 **끊김**
3. 모든 파티션을 순서대로 **배치**
4. 모든 컨슈머를 순서대로 **배치**
5. 라운드 로빈 전략에 맞춰 하나씩 **매핑**
    - **새로운** 파티션이 **할당됨**

### 컨슈머 이탈 후 스티키 파티션

![20241217_192927.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/컨슈머의 내부 동작 원리와 구현/15-컨슈머 파티션 할당 전략/20241217_192927.png)

1. 컨슈머 2가 그룹에서 **이탈**
2. 리밸런싱 발생
3. 리밸런싱 이전 할당이 유효한 파티션은 기존대로 할당
4. 리밸런싱 이전 할당이 유효하지 않은 파티션은 순서대로 **배치**
5. 할당 파티션 수의 **균형**을 맞추며 컨슈머들에게 **재할당**

### 재할당 규칙

- 컨슈머들의 최대 할당 파티션 수의 차이는 1
- 기존에 존재하는 파티션 할당은 최대한 유지
- 재할당 시 유효하지 않은 모든 파티션 할당은 제거
- 할당되지 않은 파티션들은 균형을 맞추는 방법으로 컨슈머들에게 할당

# 4. `CooperativeStickyAssignor`: 협력적 스티키 파티션

## 0. 스티키 전략과 비교

- **공통점**: 리밸런싱이 발생해도, 최소한의 파티션만 새로 매핑
- **차이점**: 컨슈머 그룹 내부 리밸런싱 동작이 고도화됨

## 1. 문제: 컨슈머 다운타임

### 한 번의 리밸런싱, 모든 파티션 할당을 취소

- 한 컨슈머 그룹 내, 여러 컨슈머가 동일한 파티션을 소유할 수 없음
- 따라서 파티션 소유권을 넘기려면, 어떤 컨슈머도 소유권을 갖지 않는 상태로 만들어야

- 그룹 내에서 파티션들에 대한 소유권 변경 작업이 동시에 일어나야
- 로직을 단순화하기 위해 모든 파티션 할당을 취소

**→ 전체적인 리밸런싱을 수행하며 컨슈머 다운타임이 발생**

### `EAGER` 프로토콜 동작

- 모든 파티션 할당을 취소하는 **`EAGER`** 프로토콜은 다음과 같이 동작

![20241217_192947.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/컨슈머의 내부 동작 원리와 구현/15-컨슈머 파티션 할당 전략/20241217_192947.png)

1. **감지**: 컨슈머의 다운을 감지
2. **중지**: 컨슈머에 할당된 모든 파티션 제거
    - 컨슈머에 할당된 파티션이 없으므로, 컨슈머 다운타임 시작
    - 프로듀서의 동작은 유지되므로, LAG이 급격하게 증가
3. **재시작**: 구독한 파티션이 컨슈머들에게 재할당

## 2. 해결책: 협력적 스티키 리밸런싱

### 여러 번의 리밸런싱, 일부 파티션 할당만 취소

- 되도록 동작 중인 컨슈머들에게 영향을 주지 않는 상태에서 몇 차례에 걸쳐 리밸런싱 수행

### `COOPERATIVE` 프로토콜 동작

- 재배치가 필요하지 않은 컨슈머들은 다운타임 없이 동작

![20241217_193000.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/컨슈머의 내부 동작 원리와 구현/15-컨슈머 파티션 할당 전략/20241217_193000.png)

1. **합류 감지**
    1. **코디네이터**: 컨슈머 합류 요청을 감지하고, 모든 컨슈머에게 그룹 재합류를 요청
    2. **컨슈머**: 그룹 합류 요청과 기존 할당 정보를 코디네이터에게 전달
    3. **코디네이터**: 전달 받은 정보를 조합해, 컨슈머 그룹 리더에게 전달
    
2. **리밸런싱 (1)**: 2번 파티션만 제외, 기존 컨슈머 그대로 동작
    1. **리더**: 제외해야 할 파티션 정보가 담긴 할당 정보를 멤버들에게 전달
    2. **멤버**: 전달 받은 할당 정보를 사용해, 필요 없는 파티션을 제외
    
3. **리밸런싱 (2)**: 2번 파티션만 재할당, 기존 컨슈머 그대로 동작
    1. **코디네이터**: 제외된 파티션 재할당을 위해, 모든 컨슈머에게 그룹 재합류를 요청
    2. **컨슈머**: 그룹 합류 요청을 코디네이터에게 전달
    3. **리더**: 제외된 파티션을 적절한 컨슈머에게 할당
</aside>