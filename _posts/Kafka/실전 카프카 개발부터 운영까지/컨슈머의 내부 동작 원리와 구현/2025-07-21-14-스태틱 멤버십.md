---
layout: single
title: "3. 스태틱 멤버십"
categories:
  - Kafka
  - 실전 카프카 개발부터 운영까지
  - 컨슈머의 내부 동작 원리와 구현
tags:
  - Kafka
  - 실전 카프카 개발부터 운영까지
  - 컨슈머의 내부 동작 원리와 구현
toc: true
toc_sticky: true
---
# 문제: 재시작으로 인한 리밸런싱

- 관리자가 그룹 내 컨슈머를 순차적으로 재시작하는 경우, 상당한 시간이 소요됨
    
    ---
    1. 컨슈머 식별을 위한 **임시 엔티티 ID** 부여
        - 임시 엔티티 ID: 컨슈머 그룹 내에서 **임시**로 사용
    2. 컨슈머 종료
        1. **새로운 엔티티 ID** 부여
        2. 컨슈머 그룹 **리밸런싱**
    3. 컨슈머 **재시작**: 이전과 동일한 컨슈머가 재합류해도, **새로운 컨슈머**로 인식
        1. **새로운 엔티티 ID** 부여
        2. 컨슈머 그룹 **리밸런싱**
    ---

# 해결책: 스태틱 멤버십

- 그룹 내 컨슈머에게 정식 엔티티 ID를 부여해, 컨슈머의 재합류 시 리밸런싱이 발생하지 않음
- 스태틱 멤버십 컨슈머는 그룹 이탈 시에 코디네이터에게 알리지 않아, 리밸런싱이 발생하지 않음

1. 컨슈머 식별을 위한 **정식 엔티티 ID** 부여
2. 컨슈머 종료: 그룹 이탈 시 코디네이터에게 알리지 않아 리밸런싱 발생 X
3. 컨슈머 **재시작**: ID로 이전과 동일한 컨슈머가 재합류한 것을 파악해 리밸런싱 발생 X

- 스태틱 멤버십 적용 옵션
    
    ```yaml
    # 카프카 2.3 이상부터 사용 가능
    group.instance.id=컨슈머_인스턴스별_고유한_값
    session.timeout.ms=컨슈머_재시작_시간보다_큰_값
    ```
    
    - 그룹 코디네이터가 컨슈머를 식별하기 위해 컨슈머 인스턴스별로 고유한 값을 입력해야
    - 컨슈머 재시작 후 `session.timeout.ms` 지정 시간동안 heartbeat 미 수신 시 리밸런싱 발생

# 일반 컨슈머 그룹 리밸런싱

## 코드

- `KafkaStandardConsumerConfig`

```java
import static org.apache.kafka.clients.consumer.ConsumerConfig.*;

@Configuration
	public class KafkaStandardConsumerConfig {
	
	@Bean
	public ConsumerFactory<String, String> consumerFactory() {
		return new DefaultKafkaConsumerFactory<>(Map.of(
				BOOTSTRAP_SERVERS_CONFIG, "peter-kafka01.foo.bar," +
										  "peter-kafka02.foo.bar," +
										  "peter-kafka03.foo.bar",
				GROUP_ID_CONFIG, "peter-consumer01",
				KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class,
				VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class,
				AUTO_OFFSET_RESET_CONFIG, "earliest"
		);
	}
	
	@Bean
	public ConcurrentKafkaListenerContainerFactory<String, String> 
			standardKafkaListenerContainerFactory() {
		
		ConcurrentKafkaListenerContainerFactory<String, String> factory 
				= new ConcurrentKafkaListenerContainerFactory<>();
		factory.setConsumerFactory(consumerFactory());
		return factory;
	}
}
```

- `ConsumerStandard`

```java
@Component
public class ConsumerStandard {

	@KafkaListener(
			topics = {"peter-test06"},
			groupId = "peter-consumer01",
			containerFactory = "standardKafkaListenerContainerFactory"
	)
	public void listen(ConsumerRecord<String, String> record) {
		System.out.printf(
				"Topic: %s, Partition: %s, Offset: %d, Key: %s, Value: %s\n",
				record.topic(), record.partition(), 
				record.offset(), record.key(), record.value()
		);
	}
}
```

## 동작

- 브로커 수 3, 토픽 수 1, 리플리케이션 팩터 수 3, 컨슈머 수 3 가정
    
    ![20241217_192715.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/컨슈머의 내부 동작 원리와 구현/14-스태틱 멤버십/20241217_192715.png)
    
- `peter-kafka01` 강제 종료 후 상태는 다음과 같음
    
    ![20241217_192727.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/컨슈머의 내부 동작 원리와 구현/14-스태틱 멤버십/20241217_192727.png)
    
    - 그룹 코니데이터가 `peter-kafka01` 이탈을 인지하고, 리밸런싱 수행
    - 컨슈머 수가 파티션 수보다 작아 `peter-kafka03`에서 실행 중인 컨슈머가 파티션 2개 담당
    - `peter-kafka02`이 담당하고 있던 파티션도 변경됨

# 스태틱 멤버십 적용 후 컨슈머 그룹 리밸런싱

## 코드

- `KafkaStaticConsumerConfig`

```java
import static org.apache.kafka.clients.consumer.ConsumerConfig.*;

@Configuration
public class KafkaStaticConsumerConfig {

@Bean
public ConsumerFactory<String, String> consumerFactory() {

	return new DefaultKafkaConsumerFactory<>(Map.of(
			BOOTSTRAP_SERVERS_CONFIG, "peter-kafka01.foo.bar," +
									  "peter-kafka02.foo.bar," +
									  "peter-kafka03.foo.bar",
			GROUP_ID_CONFIG, "peter-consumer02",
			SESSION_TIMEOUT_MS_CONFIG, "30000",
			AUTO_OFFSET_RESET_CONFIG, "earliest",
			GROUP_INSTANCE_ID_CONFIG, getHostname(),
			KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class,
			VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class
	));
	}
	
	private String getHostname() {
		try {
			return InetAddress.getLocalHost().getHostName();
		} catch (UnknownHostException e) {
			throw new RuntimeException("Failed to get hostname", e);
		}
	}
	
	@Bean
	public ConcurrentKafkaListenerContainerFactory<String, String> 
			staticKafkaListenerContainerFactory() {

		ConcurrentKafkaListenerContainerFactory<String, String> factory 
				= new ConcurrentKafkaListenerContainerFactory<>();

		factory.setConsumerFactory(consumerFactory());
		return factory;
	}
}
```

- `ConsumerStatic`

```java
@Component
public class ConsumerStatic {

	@KafkaListener(
			topics = {"peter-test06"},
			groupId = "peter-consumer02",
			containerFactory = "staticKafkaListenerContainerFactory"
	)
	public void listen(ConsumerRecord<String, String> record) {
		System.out.printf(
				"Topic: %s, Partition: %s, Offset: %d, Key: %s, Value: %s\n",
				record.topic(), record.partition(), 
				record.offset(), record.key(), record.value()
		);
	}
}
```

## 동작

- 브로커 수 3, 토픽 수 1, 리플리케이션 팩터 수 3, 컨슈머 수 3 가정
    
    ![20241217_192748.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/컨슈머의 내부 동작 원리와 구현/14-스태틱 멤버십/20241217_192748.png)
    
- `peter-kafka01` 강제 종료 후 상태는 다음과 같음
    
    ![20241217_192800.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/컨슈머의 내부 동작 원리와 구현/14-스태틱 멤버십/20241217_192800.png)
    
    - 컨슈머 수가 파티션 수보다 작아 `peter-kafka03`에서 실행 중인 컨슈머가 파티션 2개 담당

- `peter-kafka01` 재시작 후 상태는 다음과 같음
    
    ![20241217_192748.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/컨슈머의 내부 동작 원리와 구현/14-스태틱 멤버십/20241217_192748.png)
    
    - session.timeout.ms에 지정한 시간 이내에 재시작이 완료됨
    - `peter-kafka01`는 이전에 담당한 파티션 1을 다시 담당
    - `peter-kafka03`은 이전처럼 파티션 1개를 담당