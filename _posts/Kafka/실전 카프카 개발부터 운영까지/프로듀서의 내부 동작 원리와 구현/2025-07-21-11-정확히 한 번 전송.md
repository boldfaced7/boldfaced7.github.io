---
layout: single
title: "1. 정확히 한 번 전송"
categories:
  - Kafka
  - 실전 카프카 개발부터 운영까지
  - 프로듀서의 내부 동작 원리와 구현
tags:
  - Kafka
  - 실전 카프카 개발부터 운영까지
  - 프로듀서의 내부 동작 원리와 구현
toc: true
toc_sticky: true
---
# 0. 정확히 한 번 전송이란?

- 트랜잭션과 같은 전체적인 프로세스 처리를 의미
    - 중복 없는 전송은 정확히 한 번 전송의 일부 기능
    - 트랜잭션 API: 정확히 한 번 처리를 담당하는 별도의 프로세스

# 1. 디자인

- 프로듀서의 메시지는 **원자적으로** 처리되어, 전송에 성공 혹은 실패해야

## 1. 트랜잭션 코디네이터

- 프로듀서가 전송한 메시지를 관리하며, 커밋/중단 등을 표시
- 프로듀서가 전달한 트랜잭션 관련 정보로 트랜잭션 로그를 직접 기록

## 2. `__transaction_state`

- 트랜잭션 로그 관리를 위한 카프카 내부 토픽
    - `transactional.id`를 기반으로 해시하여 파티션을 결정
    - 결정된 파티션의 리더가 있는 브로커가 트랜잭션 코디네이터의 브로커로 선정됨

- 기본 설정은 다음과 같음
    
    ```
    transaction.state.log.num.partitions=50
    transaction.state.log.replication.factor=3
    ```
    

## 3. 컨트롤 메시지

- 메시지의 정상 커밋 여부를 식별하기 위한 정보
- 페이로드에 애플리이션 데이터를 포함하지 않고, 애플리케이션에 노출되지도 않음

# 2. 프로듀서 예제 코드

## 1. `KafkaConfig`

```java
import static org.apache.kafka.clients.producer.ProducerConfig.*;

@Configuration
public class KafkaExactlyOnceProducerConfig {

	@Bean
	public ProducerFactory<String, String> producerFactory() {
		return new DefaultKafkaProducerFactory<>(Map.of(
				BOOTSTRAP_SERVERS_CONFIG, "localhost:9092",
				KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class,
				VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class,

				//  (1) Exactly Once 설정
				ENABLE_IDEMPOTENCE_CONFIG, "true",
				ACKS_CONFIG, "all",
				MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, "5",
				RETRIES_CONFIG, "5",
				TRANSACTIONAL_ID_CONFIG, "peter-transaction"
		));
	}
	
	@Bean
	public KafkaTemplate<String, String> kafkaTemplate() {
		return new KafkaTemplate<>(producerFactory());
	}

	@Bean
	public KafkaTransactionManager<String, String> kafkaTransactionManager() {
		return new KafkaTransactionManager<>(producerFactory());
	}
}
```

## 2. `ExactlyOnceProducer`

```java
@Component
@RequiredArgsConstructor
public class ExactlyOnceProducer {

	private final KafkaTemplate<String, String> kafkaTemplate;
	
	@Transactional("kafkaTransactionManager")
	public void sendMessageWithTransactionalAnnotation(String key, String value) {
	
		for (int i = 0; i < 3; i++) {
			ProducerRecord<String, String> record
					= new ProducerRecord<>("peter-test05", key, value + " i");

			kafkaTemplate.send(record);
		}
	}
	
	public void sendMessageWithoutTransactionalAnnotation(String key, String value) {
	
		Producer<String, String> producer
				 = kafkaTemplate.getProducerFactory().createProducer();
		
		// (2) 트랜잭션 초기화
		producer.initTransactions();
		// (3) 트랜잭션 시작
		producer.beginTransaction();
		
		try {
			for (int i = 0; i < 3; i++) {
				ProducerRecord<String, String> record
						= new ProducerRecord<>("peter-test05", key, value + " i");

				producer.send(record);
				producer.flush();
			}
		} catch (Exception e) {
			// (4) 트랜잭션 중단
			producer.abortTransaction();
			e.printStackTrace();
		} finally {
			// (5) 트랜잭션 커밋
			producer.commitTransaction();
			producer.close();
		}
	}
}
```

# 3. 단계별 동작

- 프로듀서는 트랜잭션 API를 이용해 브로커와 통신

## 1. 트랜잭션 코디네이터 찾기

![20241217_192355.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/프로듀서의 내부 동작 원리와 구현/11-정확히 한 번 전송/20241217_192355.png)

1. **프로듀서**: `FindCoordinatorRequest`를 브로커에게 전달
2. **브로커**: 프로듀서와 트랜잭션 코디네이터를 매핑
    - `transactional.id`를 기반으로 해시해 `__transaction_state` 토픽의 파티션 결정
    - 결정된 파티션의 리더가 있는 브로커가 트랜잭션 코디네이터의 브로커로 선정됨

## 2. 프로듀서 초기화

![20241217_192417.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/프로듀서의 내부 동작 원리와 구현/11-정확히 한 번 전송/20241217_192417.png)

1. **프로듀서**: `InitPidRequest`를 트랜잭션 코디네이터에게 전달
    - TID(`transactional.id`)가 설정된 경우 함께 전송됨
2. **코디네이터**: TID, PID를 매핑하고, 해당 정보를 트랜잭션 로그에 기록
3. **코디네이터**: PID 에포크를 한 단계 올림
    - 신뢰성 있는 메시지 전송을 위해 에포크를 활용

## 3. 트랜잭션 시작

![20241217_192424.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/프로듀서의 내부 동작 원리와 구현/11-정확히 한 번 전송/20241217_192424.png)

1. **프로듀서**: `beginTransaction()`으로 트랜잭션의 시작을 기록
    - 코디네이터 관점에서는 첫 번째 레코드 전송 전까지는 트랜잭션 시작이 아님

## 4. 트랜잭션 상태 추가

![20241217_192444.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/프로듀서의 내부 동작 원리와 구현/11-정확히 한 번 전송/20241217_192444.png)

1. **프로듀서**: 토픽 파티션 정보를 코디네이터에 전달
2. **코디네이터**: 해당 데이터를 트랜잭션 로그에 기록하고, 현재 상태를 `Ongoing`으로 표시

- 트랜잭션 로그에 추가되는 첫 파티션인 경우, 코디네이터는 해당 트랜잭션에 대한 타이머 수행

## 5. 메시지 전송

![20241217_192453.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/프로듀서의 내부 동작 원리와 구현/11-정확히 한 번 전송/20241217_192453.png)

1. **프로듀서**: 대상 토픽의 파티션으로 메시지 전송
    - 해당 메시지에는 PID, 에포크, 시퀀스 번호가 함께 포함됨
2. **브로커**: 전달받은 메시지를 기록

## 6. 트랜잭션 종료 요청

![20241217_192507.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/프로듀서의 내부 동작 원리와 구현/11-정확히 한 번 전송/20241217_192507.png)

1. **프로듀서**: `commitTransaction()`/`abortTransaction()`으로 트랜잭션 종료를 알림
2. **코디네이터**: 로그에 현재 상태를 `PrepareCommit`/`PrepareAbort`로 기록

## 7. 사용자 토픽에 표시 요청

![20241217_192525.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/프로듀서의 내부 동작 원리와 구현/11-정확히 한 번 전송/20241217_192525.png)

1. **코디네이터**: 토픽의 파티션에 트랜잭션 커밋 표시 메시지 전달
    - 여기서 전달하는 메시지가 컨트롤 메시지
2. **브로커**: 전달 받은 컨트롤 메시지에 따라 해당 파티션의 오프셋을 증가시킴
    - LSO(Last Stable Offset) 오프셋으로 트랜잭션 성공/실패를 나타냄
    - 해당 메시지를 전달받아야만 트랜잭션 컨슈머에게 메시지를 전달할 수 있음

## 8. 트랜잭션 완료

![20241217_192539.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/프로듀서의 내부 동작 원리와 구현/11-정확히 한 번 전송/20241217_192539.png)

1. **코디네이터**: 로그에 현재 상태를 `CompleteCommit`로 기록
2. **코디네이터**: 프로듀서에게 해당 트랜잭션이 완료됨을 알림

- 컨슈머는 `read_commited` 설정 시, 트랜잭션에 성공한 메시지만 읽을 수 있게 됨

## 9. 전체 순서

1. **프로듀서**: `FindCoordinatorRequest`를 브로커에게 전달
2. **브로커**: 프로듀서와 트랜잭션 코디네이터를 매핑
3. **프로듀서**: `InitPidRequest`를 트랜잭션 코디네이터에게 전달
4. **코디네이터**: TID, PID를 매핑하고, 해당 정보를 트랜잭션 로그에 기록
5. **코디네이터**: PID 에포크를 한 단계 올림
6. **프로듀서**: `beginTransaction()`으로 트랜잭션의 시작을 기록
7. **프로듀서**: 토픽 파티션 정보를 코디네이터에 전달
8. **코디네이터**: 해당 데이터를 트랜잭션 로그에 기록하고, 현재 상태를 `Ongoing`으로 표시
9. **프로듀서**: 대상 토픽의 파티션으로 메시지 전송
10. **브로커**: 전달받은 메시지를 기록
11. **프로듀서**: `commitTransaction()`/`abortTransaction()`으로 트랜잭션 종료를 알림
12. **코디네이터**: 로그에 현재 상태를 `PrepareCommit`/`PrepareAbort`로 기록
13. **코디네이터**: 토픽의 파티션에 트랜잭션 커밋 표시 메시지 기록
14. **브로커**: 전달 받은 컨트롤 메시지에 따라 해당 파티션의 오프셋을 증가시킴
15. **코디네이터**: 로그에 현재 상태를 `Committed`로 기록
16. **코디네이터**: 프로듀서에게 해당 트랜잭션이 완료됨을 알림
</aside>