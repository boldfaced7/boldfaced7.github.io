---
layout: single
title: "1. 메시지 전송 방식"
categories:
  - Kafka
  - 실전 카프카 개발부터 운영까지
  - 프로듀서의 내부 동작 원리와 구현
tags:
  - Kafka
  - 실전 카프카 개발부터 운영까지
  - 프로듀서의 내부 동작 원리와 구현
toc: true
toc_sticky: true
---
# 1. 적어도 한 번 전송

- 중복 가능성 O, 손실 가능성 X
    - 카프카 기본 동작

![20241217_192254.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/프로듀서의 내부 동작 원리와 구현/10-메시지 전송 방식/20241217_192254.png)

1. **프로듀서**: 브로커의 특정 토픽으로 메시지 A 전송
2. **브로커**: 메시지 A를 저장하고 ACK를 응답
3. **프로듀서**: 다음 메시지인 메시지 B를 브로커에게 전송
4. **브로커**: 메시지 B를 저장하고, ACK를 응답
    - **네트워크 오류 또는 브로커 장애로 프로듀서는 ACK를 받지 못함**
5. **프로듀서**: 브로커가 메시지 B를 받지 못했다고 판단해 메시지 B 재전송

# 2. 최대 한 번 전송

- 중복 가능성 X, 손실 가능성 O
    - 대량의 로그 수집, IoT 환경 등에서 주로 사용

![20241217_192311.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/프로듀서의 내부 동작 원리와 구현/10-메시지 전송 방식/20241217_192311.png)

1. **프로듀서**: 브로커의 특정 토픽으로 메시지 A 전송
2. **브로커**: 메시지 A를 저장하고 ACK를 응답
3. **프로듀서**: 다음 메시지인 메시지 B를 브로커에게 전송
4. **브로커**: 메시지 B를 저장하지 못하고, ACK를 프로듀서에게 전송하지 못함
5. **프로듀서**: 브로커가 메시지 B를 받았다고 가정하고, 메시지 C 전송

# 3. 중복 없는 전송

## 0. 멱등성 확보

- 멱등성: 동일한 작업을 여러 번 수행해도 결과가 달라지지 않는 것
- 대부분의 서비스는 메시지가 중복 처리되면 안 되므로, 멱등성 확보가 중요
- 카프카는 중복 없이 메시지를 전송할 수 있는 기능을 제공

## 1. 동작

- 중복 가능성 X, 손실 가능성 X

![20241217_192325.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/프로듀서의 내부 동작 원리와 구현/10-메시지 전송 방식/20241217_192325.png)

1. **프로듀서**: 브로커의 특정 토픽으로 메시지 A, PID 0, 메시지 번호 0 전송
2. **브로커**: 메시지 A를 저장, PID, 메시지 번호를 메모리에 기록하고 ACK를 응답
3. **프로듀서**: 다음 메시지인 메시지 B, PID 0, 메시지 번호 1을 브로커에게 전송
4. **브로커**: 메시지 B를 저장, PID, 메시지 번호를 메모리에 기록하고 ACK를 응답
    - **네트워크 오류 또는 브로커 장애로 프로듀서는 ACK를 받지 못함**
5. **프로듀서**: 브로커가 메시지 B를 받지 못했다고 판단해 메시지 B 재전송
6. **브로커**: PID, 메시지 번호로 메시지 B가 저장되어 있다고 판단, 저장 없이 ACK만 응답

## 2. PID, 메시지 번호

- **PID**: 프로듀서가 할당받는 고유한 ID
- **메시지 번호**: 메시지 시퀀스로, 순차적으로 증가
- 메시지의 시퀀스 번호가 브로커가 저장한 시퀀스 번호보다 **정확히 하나 큰 경우**가 아니라면 중복 처리

## 3. 오버헤드

- 메시지 비교 동작에 오버헤드가 존재할 수밖에 없지만, 숫자 필드를 이용해 최소화
- 중복 없는 전송 적용 시, 기존 대비 최대 20% 가량 성능이 감소
- 중복 없는 전송을 위한 프로듀서 설정은 다음과 같음

```
enable.idempotence=true
max.in.flight.requests.per.connection=5 # 5 이하로 설정
ack=all
retries=5 # 0보다 큰 값
```