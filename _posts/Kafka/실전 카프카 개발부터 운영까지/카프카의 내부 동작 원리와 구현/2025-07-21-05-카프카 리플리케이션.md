---
layout: single
title: "1. 카프카 리플리케이션"
categories:
  - Kafka
  - 실전 카프카 개발부터 운영까지
  - 카프카의 내부 동작 원리와 구현
tags:
  - Kafka
  - 실전 카프카 개발부터 운영까지
  - 카프카의 내부 동작 원리와 구현
toc: true
toc_sticky: true
---
- 카프카는 일부 브로커에 장애가 발생해도 안정적인 서비스가 운영되도록 구상
- 안정성 확보를 위해 카프카 내부에서 리플리케이션 수행

<br>

# 1. 리더와 팔로워

## 1. 리더

- 모든 읽기/쓰기는 **리더를 통해서만** 가능

![20241217_184204.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_184204.png)



## 2. 팔로워

- 리더에 문제가 발생하면 **새로운 리더**가 되도록 **준비**해야
- 리더가 새로운 **메시지**를 받았는지 **확인**하고, 새로운 메시지를 리더로부터 **복제**
    - 컨슈머가 토픽에서 메시지를 가져가는 것과 유사

<br>

# 2. 복제 유지와 커밋

## 1. ISR(`InSyncReplica`)

- 리더 파티션에 대한 **리플리케이션이 동기화**된 팔로워
- ISR 그룹에 속한 팔로워만 **리더 후보**가 될 수 있음



## 2. 팔로워 점검

- **리더**는 팔로워들이 리플리케이션을 잘 수행하는지 모니터링하며 ISR 그룹을 관리



## 3. 하이워터마크

- ISR 그룹 내 팔로워의 복제가 완료되면, 리더가 내부적으로 남기는 **마지막 커밋 오프셋 위치**
- 컨슈머는 **하이워터마크까지** 기록된 메시지만 읽을 수 있음
    - 즉, 커밋 전 메시지만 읽을 수 있음
    - 메시지 **일관성** 유지를 위한 조치



## 4. 커밋 위치의 중요성

- 커밋 전 메시지를 컨슈머가 읽을 수 있다고 가정

- 리더는 `message1`에 대한 커밋까지 모두 완료된 상태에, `message2`를 받음
  
    ![20241217_184222.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_184222.png)
    
    
    
- 컨슈머 A는 리더가 가진 모든 메시지(`message1`, `message2`)를 읽음
  
    ![20241217_191548.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_191548.png)
    
  
  
- `message2` 복제 전에 리더가 다운되어, 새로운 리더가 선출됨
- 컨슈머 B는 새 리더가 가진 모든 메시지(`message1`)를 읽음
  
    ![20241217_191558.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_191558.png)

**→ 컨슈머 A-B 간 메시지 불일치 현상 발생**



## 5. replication-offset-checkpoint

- 모든 브로커가 재시작될 때 **마지막 커밋 오프셋 위치(하이워터마크)**를 저장하는 파일

<br>

# 3. 리더-팔로워 단계별 리플리케이션 동작

## 1. 문제: 리더 성능 문제

- 리더는 여러 리플리케이션 동작에 관여
- 이 때 많은 통신을 주고받는다면, **리더의 성능은 떨어질 것**



## 2. 해결책: ACK 통신 제거

- 다른 메시징 시스템과 달리, 리더-팔로워 간 **ACK 통신을 제거**
- 대량의 메시지 처리 시, **통신 부하를 50% 감소**

<br>

## 3. 문제: 통신 신뢰성

- ACK 통신이 없는 경우, 팔로워와 리더 간의 리플리케이션 동작의 **신뢰를 보장할 수 없음**



## 4. 해결책: Pull 방식

- 리더-팔로워 간 리플리케이션 동작을 **팔로워의 Pull 방식**으로 구현
- Pull 방식과 **ISR 관리**가 결합되어, 리더는 팔로워가 데이터를 복제했는지 확인할 수 있음

<br>

## 5. 리더-팔로워 리플리케이션 동작

### **`message1`: 리더만 저장**

> - **프로듀서**: `message1` 전달
> - **리더**: `message1`을 받아 0번 오프셋에 저장
> - **팔로워**: 리더가 새로운 메시지를 전달 받았다는 것을 아직 알지 못함
>

![20241217_191621.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_191621.png)

<br>

### **`message1`: 리플리케이션**

> 1. **팔로워**: 0번 오프셋 메시지 fetch 요청
> 2. **리더**: `message1` 전달
> 3. **팔로워**: 0번 오프셋의 `message1`을 리더로부터 리플리케이션
>
> - **리더**: 팔로워의 리플리케이션 성공 여부를 알지 못함
>   - 리더-팔로워 ACK 통신이 없기 때문

![20241217_191633.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_191633.png)

<br>

### **`message2`: 리더만 저장**

> 1. **프로듀서**: `message2` 전달
> 2. **리더**: `message2`를 받아 1번 오프셋에 저장
>
> - **팔로워**: 리더가 새로운 메시지를 전달 받았다는 것을 아직 알지 못함

![20241217_191650.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_191650.png)

<br>

### **`message2`: 리플리케이션**

> 1. **팔로워**: 1번 오프셋 메시지 fetch 요청
> 2. **리더**: `message2` 전달
> 3. **팔로워**: 1번 오프셋의 `message2`를 리더로부터 리플리케이션
> 4. **리더**: 팔로워의 지난 리플리케이션의 성공 여부 파악, 커밋 후 하이워터마크 증가
>     - fetch 요청의 오프셋 번호가 바뀌었기 때문(0 → 1)
>

![20241217_191710.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/1ecea3b0-d555-484e-a32c-7f020cd3b2bc.png)

<br>

# 4. 리더에포크와 복구

## 0. 리더에포크란?

- 파티션 리더가 변경될 때마다 증가하는 값
- 파티션 복구 시 메시지의 일관성 유지를 위한 용도로 사용

<br>

## 1. 사례 (1): 팔로워, 리더 순차 다운

### 1.  `message1` 전달

> 1. **리더**: `message1`을 받아 0번 오프셋에 저장
> 2. **팔로워**: 리더에게 0번 오프셋에 대한 가져오기 요청
> 3. **리더**: 팔로워에게 `message1` 전달
> 4. **팔로워**: 0번 오프셋의 `message1`을 리더로부터 리플리케이션
> 5. **팔로워**: 리더에게 1번 오프셋에 대한 가져오기 요청
> 6. **리더**: 하이워터마크 1로 상향

<br>

### 2. `message2` 전달

> 1. **리더**: `message2`를 받아 1번 오프셋에 저장
> 2. **팔로워**: 리더에게 1번 오프셋에 대한 가져오기 요청
> 3. **리더**: 팔로워에게 `message2` 전달
> 4. **팔로워**: 리더의 응답으로 하이워터마크 변화 감지 후, 1로 상향
> 5. **팔로워**: 1번 오프셋의 `message2`를 리더로부터 리플리케이션
> 6. **팔로워**: 리더에게 2번 오프셋에 대한 가져오기 요청
> 7. **리더**: 요청을 받아 하이워터마크를 2로 상향

![20241217_191729.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_191729.png)

<br>

### 3. 팔로워 다운

> 1. **팔로워**: 아직 하이워터마크를 2로 올리는 내용을 전달 받지 못함
> 2. **팔로워**: 예상치 못한 장애로 다운

<br>

## 리더에포크 사용 X

- 리더에포크를 사용하지 않은 경우, 다음과 같은 대처로 새로운 문제를 야기

<br>

### 4. 팔로워 복구

> 1. **팔로워**: 자신의 워터마크보다 높은 메시지 삭제
>     - 자신의 워터마크보다 높은 메시지는 신뢰할 수 없는 메시지로 판단
>     - 따라서 1번 오프셋의 `message2` 삭제

![20241217_191738.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_191738.png)

<br>

### 5. 리더 다운

> 1. **팔로워**: 리더에게 1번 오프셋에 대한 가져오기 요청
> 1. **리더**: 예상치 못한 장애로 다운
> 3. **팔로워**: 새로운 리더로 승격

​	**→ `message2` 유실**

![20241217_191749.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_191749.png)

<br>

## 리더에포크 사용 O

- 리더에포크를 사용하는 경우, 다음과 같은 대처로 데이터 일관성을 유지

<br>

### 4. **팔로워 복구**

> 1. **팔로워**: 리더에게 리더에포크 요청
> 2. **리더**: 팔로워에게 "1번 오프셋의 `message2`까지" 전달
> 3. **팔로워**: `message2` 삭제하지 않고, `message2`까지 하이워터마크 상향
> 4. **팔로워**: 자신의 워터마크보다 높은 메시지 삭제

![20241217_191804.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_191804.png)

<br>

### 5. 리더 다운

> 1. **리더**: 예상치 못한 장애로 다운
> 2. **팔로워**: 새로운 리더로 승격

​	**→ `message2` 유실되지 않음**

![20241217_191823.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_191823.png)

<br>

## 2. 사례 (2): 리더, 팔로워 동시 다운

### 1. `message1` 전달

> 1. **리더**: `message1`을 받아 0번 오프셋에 저장
> 2. **팔로워**: 리더에게 0번 오프셋에 대한 가져오기 요청
> 3. **리더**: 팔로워에게 `message1` 전달
> 4. **팔로워**: 0번 오프셋의 `message1`을 리더로부터 리플리케이션
> 5. **팔로워**: 리더에게 1번 오프셋에 대한 가져오기 요청
> 6. **리더**: 하이워터마크 1로 상향

<br>

### 2. `message2` 전달

> 1. **리더**: `message2`를 받아 1번 오프셋에 저장
> 2. **팔로워**: 리더에게 1번 오프셋에 대한 가져오기 요청
> 3. **리더**: 팔로워에게 `message2` 전달

![20241217_191831.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_191831.png)

<br>

### 3. 리더, 팔로워 다운

> 1. **팔로워**: 2번 오프셋의 `message2` 리플리케이션 진행 중
> 2. **리더, 팔로워**: 예상치 못한 장애로 다운

<br>

## 리더에포크 사용 X

### 4. **팔로워 먼저 복구**

> 1. **팔로워**: 새로운 리더(**New 리더**)로 승격

<br>

### 5. `message3` 전달

> 1. **New 리더**: `message3`을 받아 2번 오프셋에 저장
> 2. **New 리더**: 하이워터마크 2로 상향

![20241217_191844.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_191844.png)

<br>

### 6. 리더 복구

> 1. **리더**: 이미 리더가 있어, 새로운 팔로워(**New 팔로워**)가 됨
> 2. **New 팔로워**: 리더와 하이워터마크 비교 후, 메시지를 삭제하지 않기로 결정

<br>

### 7. **프로듀서**: `message4` 전달

> 1. **New 리더**: `message4`를 받아 2번 오프셋에 저장
> 2. **New 팔로워**: 2번 오프셋의 `message4`를 리더로부터 리플리케이션

​	**→ 리더-팔로워 메시지 불일치 발생**

![20241217_191905.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_191905.png)

<br>

## 리더에포크 사용 O

### 4. **팔로워 먼저 복구**

> 1. **팔로워**: 새로운 리더(**New 리더**)로 승격

<br>

### 5. `message3` 전달

> 1. **New 리더**: `message3`을 받아 2번 오프셋에 저장
> 2. **New 리더**: 하이워터마크 2로 상향

![20241217_191844.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_191844.png)

<br>

### 6. 리더 복구

> 1. **리더**: 이미 리더가 있어, 새로운 팔로워(**New 팔로워**)가 됨
> 2. **New 팔로워**: New 리더에게 리더에포크 요청
> 3. **New 리더**: 팔로워에게 "0번 오프셋의 `message1`까지" 전달
> 4. **New 팔로워**: 메시지 일관성을 위해 1번 오프셋의 `message2` 삭제
>     - 팔로워는 쓰기 권한이 없어, 리더에게 `message2`를 추가할 수 없음
> 5. **New 팔로워**: 1번 오프셋의 `message3`을 리더로부터 리플리케이션

<br>

### 7. **프로듀서**: `message4` 전달

> 1. **New 리더**: `message4`를 받아 2번 오프셋에 저장
> 2. **New 팔로워**: 2번 오프셋의 `message4`를 리더로부터 리플리케이션

​	**→ 리더-팔로워 메시지 불일치 발생하지 않음**

![20241217_191918.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_191918.png)

<br>


## 3. leader-epoch-checkpoint

- 카프카는 `leader-epoch-checkpoint` 파일에 리더에포크 상태를 기록
    - 현재 리더에포크 번호, 이전 리더에포크 번호와 하이워터마크 번호가 누적되어 있음
    - 리더에포크 번호는 리더가 변경될 때마다 1씩 증가

- 다운된 브로커는 `leader-epoch-checkpoint` 정보를 이용해 복구
  
    > **구 리더**: 1번 리더에포크에 대한 요청 전송
    >
    > **신 리더**: 1번 리더 에포크의 최종 커밋 후 준비된 오프셋 위치가 1이라는 응답 전송



## 4. 리더에포크 변화 과정

### **토픽 생성 직후**

![20241217_191935.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_191935.png)

- `leader-epoch-checkpoint`
  
    ```java
    0
    1   // 현재 리더에포크 번호
    0 0 // 첫 번째 0: 리더에포크 번호, 두번째 0: 하이워터마크 번호
    ```
    

<br>

### **메시지 전송 직후**

![20241217_191952.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_191952.png)

- `leader-epoch-checkpoint`
  
    ```java
    0
    1   // 현재 리더에포크 번호
    0 0 // 첫 번째 0: 리더에포크 번호, 두번째 0: 하이워터마크 번호
    ```
    

<br>

### **리더 브로커 종료 직후**

![20241217_192009.png](/assets/images/Kafka/실전 카프카 개발부터 운영까지/카프카의 내부 동작 원리와 구현/05-카프카 리플리케이션/20241217_192009.png)

- `leader-epoch-checkpoint`
  
    ```java
    0
    2    // 현재 리더에포크 번호 이전 대비 1 증가
    0 0  // 첫 번째 0: 리더에포크 번호, 두번째 0: 하이워터마크 번호
    1 1  // 첫 번째 1: 리더에포크 번호, 두번째 1: 하이워터마크 번호
    ```