---
layout: single
title: "3. 상세 설계"
categories:
  - Kafka
  - 가상 면접 사례로 배우는 대규모 시스템 설계 기초 2
  - 분산 메시지 큐
tags:
  - Kafka
  - 분산 메시지 큐
toc: true
toc_sticky: true
---
# 0. 중요 결정 사항

## 1. 디스크 기반 자료 구조 사용

- 높은 순차 탐색 성능을 가짐
- 현대 운영체제가 제공하는 적극적인 디스크 캐시 전략을 이용

## 2. 메시지 자료 구조 설계

- 메시지가 전달될 때 아무 수정 없이 전송이 가능한 메시지 자료 구조를 설계해 활용

## 3. 일괄 처리 우선 시스템

- 일괄 처리를 장려해 높은 대역폭을 지원
    - **생산자**: 메시지를 일괄 전송
    - **메시지 큐**: 메시지들을 더 큰 단위로 묶어 보관
    - **소비자**: 메시지를 일괄 수신

---
# 1. 데이터 저장소

## 1. 메시지 큐의 트래픽 패턴

- 읽기/쓰기가 빈번
- 순차적인 읽기/쓰기가 대부분
- 갱신/삭제는 없음

## 2. 데이터베이스?

- 토픽별로 테이블/컬렉션을 생성해 메시지를 저장
- 읽기/쓰기 연산이 동시에 대규모로 빈번하게 발생하는 데이터 사용 패턴에 부적합

## 3. 쓰기 우선 로그(Write-Ahead Log, WAL)

### 지속성과 WAL

- **WAL**: append-only 일반 파일
- 지속성을 보장해야 하는 메시지는 디스크에 WAL로 보관하는 것을 추천
- 읽기/쓰기 전부 순차적이라, 디스크에서 좋은 성능을 낼 수 있음

### 동작 원리

- 새로운 메시지는 파티션 꼬리 부분에 추가되며, 오프셋은 점진적으로 증가
- 파일의 크기를 무한정으로 키울 수는 없으므로, 데이터를 세그먼트 단위로 나눔

![03jxocat.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/03jxocat.bmp)

### 세그먼트 파일의 상태와 읽기/쓰기 연산

- 새 메시지는 활성 상태의 세그먼트 파일에만 추가됨
- 세그먼트 크기가 한계에 도달하면, 새 활성 새그먼트 파일을 생성
- 기존 세그먼트 파일은 비활성화(읽기만 가능)

## 4. 디스크 성능 관련 유의사항

- 회전식 디스크는 무작위 접근 시에만 느려지며, 순차 접근 시에는 빠름
- 현대 OS가 제공하는 디스크 캐시 전략을 이용하면, 접근 속도를 극대화할 수 있음

---
# 2. 메시지 자료 구조

- 메시지 데이터 스키마
    
    
    | 필드 이름 | 데이터 자료형 |
    | --- | --- |
    | key | byte[] |
    | value | byte[] |
    | topic | string |
    | partition | integer |
    | offset | long |
    | timestamp | long |
    | size | integer |
    | crc(cycle redundancy check) | integer |

---
# 3. 일괄 처리

- 일괄 처리는 네트워크 왕복 비용을 최소화하고, 디스크 접근 대역폭을 높여, 성능 개선에 중요
- 하지만 높은 대역폭과 낮은 응답 지연을 동시에 달성하는 것은 어려움
    - 응답 지연을 낮추기 위해 일괄 처리 메시지 양을 줄이면, 디스크 성능은 낮아짐
    - 처리량을 높이기 위해서는 토픽당 파티션의 수를 늘려야

---
# 4. 작업 흐름

## 1. 생산자 측

- **라우팅 계층:** 리더 브로커에 메시지를 보내는 역할을 담당
    
    ![czm1egm0.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/czm1egm0.bmp)
    

- 라우팅 계층을 적절히 사용해야, 성능을 최적화할 수 있음
    - 불필요한 네트워크 노드를 늘리지 않아야, 네트워크 전송 지연을 줄일 수 있음
    - 일괄 처리가 가능하도록 설계해야, 효율을 극대화할 수 있음

- 라우팅 계층을 생산자 내부로 편입시키고 버퍼를 도입해 성능을 최적화할 수 있음
    
    ![2b6ookl4.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/2b6ookl4.bmp)
    
    - 네트워크를 거칠 필요가 줄어들어, 전송 지연도 줄어듦
    - 생산자는 메시지를 어느 파티션에 보낼지 결정하는 로직을 가질 수 있음
    - 전송할 메시지를 버퍼 메모리에 보관했다가 목적지로 일괄 전송할 수 있음

## 2. 소비자 측

- 특정 파티션의 오프셋을 주고, 해당 위치에서부터 이벤트를 묶어 가져옴

![lemzbatt.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/lemzbatt.bmp)

---
# 5. 푸시 vs 풀

## 1. 푸시 모델: 브로커가 데이터를 소비자에게 보냄

### 장점

- 브로커가 메시지를 받는 즉시 소비자에게 보낼 수 있어, 전송 지연을 줄일 수 있음

### 단점

- 메시지 생산 속도가 메시지 소비 속도보다 빠른 경우, 소비자에게 큰 부하가 걸림
- 생산자가 데이터 전송 속도를 좌우하므로, 소비자는 항상 그에 맞는 컴퓨팅 자원을 준비해야

## 2. 풀 모델: 소비자가 데이터를 브로커에서 가져감

### 장점

- 메시지 소비 속도를 소비자가 결정(실시간/일괄)
- 메시지 소비 속도가 느려지면, 소비자를 늘리거나 생산 속도를 따라 잡을 때까지 기다릴 수 있음
- 일괄 처리에 적합
    - 푸시 모델: 처리 못한 메시지는 버퍼에 쌓여 처리를 기다림
    - 풀 모델: 오프셋 값을 이용해 특정 위치해서 적절한 수의 메시지를 한 번에 가져갈 수 있음

### 단점

- 메시지가 없어도 소비자는 계속 데이터를 끌어가려 시도해, 컴퓨팅 자원이 낭비됨
    - 롱 폴링 지원 모드(가져갈 메시지가 없더라도 일정 시간 기다림)로 극복 가능

## 3. 풀 모델의 동작 흐름

![w5ogvt9v.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/w5ogvt9v.bmp)

---
1. 그룹 1에서 토픽 A를 구독할 새로운 소비자가 합류
    - 그룹 이름을 해싱해 접속할 브로커 노드(코디네이터)를 찾음
2. 코디네이터는 해당 소비자를 그룹에 참여시키고, 파티션 2를 할당
3. 소비자는 마지막으로 소비한 오프셋 이후의 메시지를 가져옴
    - 오프셋 정보는 상태 저장소에 보관되어 있음
4. 소비자는 메시지를 처리하고 새로운 오프셋을 브로커에게 보냄

---
# 6. 소비자 재조정

- 어떤 소비자가 어떤 파티션을 책임질지 다시 정하는 프로세스

## 1. 코디네이터

- 소비자 재조정을 위해 소비자들과 통신하는 브로커 노드
- 소비자가 보내는 heartbeat 메시지를 살피고, 각 소비자의 파티션 내 오프셋 정보를 관리
    
    ![o2eax6bv.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/o2eax6bv.bmp)
    

- 소비자 장애 감지 시, 재조정 프로세스를 시작해, 파티션을 재배치
    
    ![xqvjz485.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/xqvjz485.bmp)
    

## 2. 재조정 시나리오

### 새로운 소비자 B 합류

![oewuggwx.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/oewuggwx.bmp)

---

**1a**. heartbeat 메시지(A→C)

**1b**. heartbeat 메시지 정상 수신 회신(C→A)

**2a**. 그룹 합류 요청(B→C)

**3a**. heartbeat 메시지(A→C)

**3b**. 응답(C→A): ”소비자 재조정이 필요하므로, 다시 그룹에 합류할 것”

**4a**. 그룹 합류 요청

**4b**. 응답

C→A: ”비-리더로 그룹에 정상 합류”

C→B: ”리더로 그룹에 정상 합류했으며, 그룹 멤버는 A, B임”

**5**. 그룹 동기화 요청

A→C: “리더가 파티션 배치 계획을 보내길 대기”

B→C: “파티션 배치 계획 전송”

**6**. 그룹 동기화

C→A: “A에 파티션 1, 3 배치”

C→B: “B에 파티션 2, 4 배치”

---

### 기존 소비자 A 이탈

![nhd8rhhq.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/nhd8rhhq.bmp)

---

**1a**. heartbeat 메시지(A→C, B→C)

**1b**. heartbeat 메시지 정상 수신 회신(C→A, C→B)

**2a**. 그룹 탈퇴 요청(A→C)

**2b**. 탈퇴 요청 승인(C→A)

**3a**. heartbeat 메시지(B→C)

**3b**. 응답(B→C): ”소비자 재조정이 필요하므로, 다시 그룹에 합류할 것”

**4a**. 그룹 합류 요청(B→C)

**4b**. 응답(C→B): ”리더로 그룹에 정상 합류했으며, 그룹 멤버는 B임”

**5**. 그룹 동기화 요청(B→C): “파티션 배치 계획 전송”

**6**. 그룹 동기화(C→B): “B에 파티션 1, 2, 3, 4 배치”

---

### 소비자 A의 비정상적인 가동 중단

![rx7ymkey.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/rx7ymkey.bmp)

---

**1a**. heartbeat 메시지(A→C, B→C)

**1b**. heartbeat 메시지 정상 수신 회신(C→A, C→B)

**2**. 소비자 A로부터 더 이상의 heartbeat 메시지가 없음

장애가 발생한 것으로 보이므로, 소비자 재조정이 필요

**3a**. heartbeat 메시지(B→C)

**3b**. 응답(B→C): ”소비자 재조정이 필요하므로, 다시 그룹에 합류할 것”

**4a**. 그룹 합류 요청(B→C)

**4b**. 응답(C→B): ”리더로 그룹에 정상 합류했으며, 그룹 멤버는 B임”

**5**. 그룹 동기화 요청(B→C): “파티션 배치 계획 전송”

**6**. 그룹 동기화(C→B): “B에 파티션 1, 2, 3, 4 배치”

---

# 7. 상태 저장소

## 1. 저장 항목

- 소비자에 대한 파티션 배치 관계
- 각 소비자 그룹이 각 파티션에서 마지막으로 가져간 메시지의 오프셋

## 2. 동작 사례

- 그룹 1의 한 소비자가 파티션의 메시지를 순서대로 읽은 후, 마지막 오프셋을 6으로 갱신
- 해당 소비자에 장애가 생기면, 그룹 내 새로운 소비자가 해당 위치 다음부터 메시지를 읽음

![ot08z79s.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/ot08z79s.bmp)

## 3. 소비자 상태 정보 이용 패턴

- 읽기와 쓰기가 빈번하게 발생하나, 양은 많지 않음
- 데이터 갱신은 빈번하게 발생하나, 삭제는 거의 없음
- 읽기와 쓰기 연산이 무작위 패턴을 보임
- 데이터의 일관성이 중요

# 8. 메타데이터 저장소

- 토픽 설정, 속성 정보(파티션 수, 메시지 보관 기관, 사본 배치 정보 등) 보관
- 메타데이터는 자주 변경되지 않고 양도 적으나, 높은 일관성이 필요

---
# 9. 주키퍼

- 계층적 키-값 저장소 기능을 제공하며, 분산 시스템에 필수적인 서비스
    
    ![w1hpoggy.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/w1hpoggy.bmp)
    
    - 메타데이터와 상태 저장소는 주키퍼로 구현
    - 브로커는 이제 메시지 데이터 저장소만 유지
    - 주키퍼가 브로커 클러스터의 리더 선출 과정을 도움

---
# 10. 복제

- 디스크 장애 문제를 대비하고 높은 가용성을 보장하기 위해 전통적으로 많이 사용됨

## 1. 동작 사례

- 각 파티션은 3개의 사본을 갖고, 해당 사본들은 서로 다른 브로커 노드에 분산됨
    
    ![fn5bqnzu.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/fn5bqnzu.bmp)
    
    - 생산자는 파티션에 메시지를 보낼 때, 리더에게만 보냄
    - 다른 사본은 리더에서 새 메시지를 지속적으로 가져와 동기화
    - 메시지를 완전히 동기화한 사본 개수가 임계값을 넘으면, 리더는 생산자에게 ACK 전달

## 2. 사본 분산 계획

- 사본을 파티션에 어떻게 분산할지 기술한 것으로, 리더가 만들어 메타데이터 저장소에 보관

---
# 11. 사본 동기화

## 1. 동기화된 사본(In-Sync Replicas, ISR)

- ‘동기화되었다’가 무엇을 의미하는지는 토픽의 설정에 따라 달라짐
    - `replica.lag.max.messages` 값이 4일 때, 사본 메시지 개수와 리더 사이의 차가 3이라면, 해당 사본은 ISR

- **합의 오프셋**: 해당 오프셋 이전에 기록된 모든 메시지는 ISR 집합 내 모든 사본과 동기화되었음을 의미

### ISR 동작 사례

- 리더의 합의 오프셋 값은 13, 2개의 새로운 메시지는 사본 간 합의가 이뤄지지 않음
- 사본 2, 3은 리더 상태를 동기화해 ISR이 되었으므로, 새로운 메시지를 가져올 수 있음
- 사본 4는 리더 상태를 따라잡지 못해 아직 ISR이 아님

![oca2gwpz.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/oca2gwpz.bmp)

### 성능-영속성 트레이드 오프

- ISR은 성능과 영속성 사이의 타협점
- 생산자 메시지를 소실하지 않으려면 모든 사본을 동기화하고 ACK를 보내야
- 하지만 한 사본이라도 동기화를 신속하게 처리하지 못하면, 성능이 저하됨

## 2. 메시지 수신 응답(ACK) 설정

### ACK=all

- 생산자는 모든 ISR이 메시지를 수신한 뒤 ACK 응답을 받음
    
    ![x1f88wuw.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/x1f88wuw.bmp)
        
    1. 메시지 생산
    2. 새 메시지 읽음
    3. 동기화 완료
    4. 메시지 수신 확인 응답


- 메시지 영속성 측면에서는 가장 좋은 구성
- 가장 느린 ISR의 응답을 기다려야 해, 성능 측면에서는 가장 나쁜 구성

### ACK=1

- 생산자는 리더가 메시지를 수신한 뒤 바로 ACK 응답을 받음
    
    ![som6ixry.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/som6ixry.bmp)
    
    
    1. 메시지 생산
    2. 메시지 수신 확인 응답


- 데이터 동기화를 기다리지 않아, 응답 지연은 개선됨
- ACK 전달 직후 리더에 장애가 발생하면, 해당 메시지는 복구 불가
- 데이터가 사라져도 상관 없는 대신, 낮은 응답 지연을 보장해야 하는 시스템에 적합

### ACK=0

- 생산자는 ACK를 기다리지 않고 계속 메시지를 전송
    
    ![befo0dte.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/befo0dte.bmp)
    
    
    1. 메시지 생산


- 낮은 응답 지연 달성을 위해 메시지 손실을 감수
- 처리할 메시지 양이 많고, 데이터 손실이 발생해도 상관 없는 시스템(지표 수집, 데이터 로깅)에 적합

## 3. 소비자와 ISR

### 리더 사본에서 메시지 가져가기

- 설계/운영이 단순
- 리더에 대한 연결은 많지 않음
    - 특정 파티션의 메시지는 소비자 그룹 내 한 소비자만 읽을 수 있음

- 아주 인기 있는 토픽이 아니라면, 리더에 대한 연결의 수는 그렇게 많지 않음
- 아주 인기 있는 토픽이라면, 파티션 및 소비자 수를 늘려 규모를 확장하면 됨

### ISR 사본에서 메시지 가져가기

- 소비자 위치가 리더 사본이 존재하는 데이터 센터와 다른 지역인 경우

---
# 12. 규모 확장성

## 1. 생산자

- 생산자는 그룹 단위 조정에 가담할 필요가 전혀 없음
- 생산자의 규모 확장성은 생산자 추가/삭제로 쉽게 달성 가능

## 2. 소비자

- 소비자 그룹과 재조정 매커니즘이 소비자 측 규모 확장성과 결함 내성을 보장
    - 소비자 그룹은 서로 독립적이므로 쉽게 추가/삭제가 가능
    - 소비자 그룹 내 소비자의 추가/삭제는 재조정 메커니즘이 맡아 처리

## 3. 브로커

### 브로커의 장애 복구

- 특정 브로커에 장애가 발생할 경우, 브로커 컨트롤러에서 새로운 파티션 분산 계획을 수립
    
    ![v22idwe6.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/v22idwe6.bmp)
    

### 브로커의 결함 내성을 높이기 위한 추가 고려사항

- ACK 값이 높을수록 안전하지만, 성능과 안정성 사이에서 균형을 찾아야
- 사본을 같은 노드에 두면, 장애 발생 시 완전 소실될 수도
- 사본 수/위치를 정할 때는 데이터 안정성, 자원 유지 비용, 응답 지연 들을 고려해야

### 브로커 노드 추가/삭제

- 브로커 컨트롤러에게 시스템에 설정된 사본 수보다 많은 사본을 한시적으로 허용
    
    ![iyfr0p1n.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/iyfr0p1n.bmp)
    

## 4. 파티션

### 파티션 추가

- 지속적으로 보관된 메시지는 여전히 기존 파티션에 존재, 해당 데이터는 이동하지 않음
- 새로운 파티션이 추가되면, 이후 오는 메시지는 모든 파티션에 지속적으로 보관됨

![7k0k4nrg.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/7k0k4nrg.bmp)

### 파티션 삭제

- 특정 파티션의 퇴역 결정이 내려지면, 새로운 메시지는 다른 파티션에만 보관
- 소비자를 위해 퇴역 파티션은 바로 제거되지 않고 일정 시간 유지하되, 새로 메시지를 보관하지는 않음
- 파티션 제거 시점에 생산자 그룹은 재조정 작업을 개시

![3zguu2kg.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/3zguu2kg.bmp)

---
# 13. 메시지 전달 방식

## 1. 최대 한 번

- 전달 중 메시지가 소실되어도, 다시 전달하지 않음
    
    ![e573a4ni.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/e573a4ni.bmp)
    
    - **생산자**: 비동기적으로 메시지를 보내고, 수신 응답을 기다리지 않음(ACK=0)
        - 메시지 전달에 실패해도, 재시도하지 않음
    
    - **소비자**: 메시지를 읽고 처리하기 전에 오프셋부터 갱신
        - 오프셋 갱신 직후 소비자가 죽으면, 메시지는 다시 소비될 수 없음

- 소량의 데이터 손실은 감수할 수 있는 애플리케이션(지표 모니터링 등)에 적합

## 2. 최소 한 번

- 같은 메시지가 한 번 이상 전달될 수는 있으나, 메시지 소실은 발생하지 않음
    
    ![y6zat5fc.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/y6zat5fc.bmp)
    
    - **생산자**: 메시지를 동기/비동기적으로 보내고, 메시지가 브로커에 전달되었음을 확인(ACK=1 or ACK=all)
        - 메시지 전달 실패 또는 타임아웃 발생 시, 계속 재시도
    
    - **소비자**: 데이터를 성공적으로 처리한 후에만 오프셋을 갱신
        - 메시지 처리에 실패하는 경우, 메시지를 다시 가져옴
        - 오프셋을 갱신하지 못하고 소비자가 죽으면, 메시지는 중복 처리됨

- 데이터 중복이 큰 문제가 아닌 경우에 적합
    - 메시지마다 키가 있는 경우, 해당 키가 이미 DB에 있는 메시지는 처리하지 않고 버림

## 3. 정확히 한 번

- 같은 메시지가 여러 번 전달될 수는 없고, 메시지 소실도 발생하지 않음
    
    ![yiizti9d.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/yiizti9d.bmp)
    
    - 시스템 성능 및 구현 복잡도 측면에서 가장 어려움

- 중복을 허용하지 않으며, 외부 서비스가 같은 입력에 항상 같은 결과를 내놓도록 구현되지 않은 경우 적합
    - 금융 관련 서비스(지불, 매매, 회계 등)에 적합

---
# 14. 메시지 필터링

## 1. 토픽 분리

- 필터링이 필요할 때마다 전용 토픽을 구현하는 것은 번거로움
- 같은 메시지를 여러 토픽에 저장하는 것은 자원 낭비
- 생산자와 소비자 사이 결합도가 높아져, 소비자의 새로운 요구사항에 따라 구현을 바꿔야

## 2. 메시지 필터링

### 모든 메시지를 받아서 필터링

- 유연성은 높지만, 불필요한 트래픽으로 시스템 성능이 저하됨

### 브로커에서 메시지를 필터링

- 메시지 내용을 읽는 과정에 복호화/역직렬화가 필요하다면 브로커 성능이 저하됨
- 메시지에 민감한 데이터가 들어가 있는 경우, 메시지 큐에서 메시지를 읽는 행위가 문제가 됨

### 브로커에서 메타데이터를 필터링

![rj9wwvnf.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/rj9wwvnf.bmp)

- 필터링에 사용할 데이터를 메시지의 메타데이터에 저장
- 소비자는 어떤 태그를 가진 메시지를 구독할지 지정

---
# 15. 메시지 지연/예약 전송

- 브로커 내부 임시 저장소에 넣어 두었다가 시간이 되면 토픽으로 옮김
    
    ![976h5ho8.bmp](/assets/images/Kafka/가상 면접 사례로 배우는 대규모 시스템 설계 기초 2/분산 메시지 큐/03-상세 설계/976h5ho8.bmp)